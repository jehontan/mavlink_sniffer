from enum import IntEnum
from abc import ABC, abstractmethod
import struct
from typing import Dict, Type, Optional, Tuple
from dataclasses import dataclass

class Unpackable(ABC):
    @classmethod
    @abstractmethod
    def unpack(cls, data: bytes, offset: int = 0):
        return NotImplemented

class MessageRegister:
    name_to_id : Dict[str, int] = {}
    id_to_type : Dict[int, Type[Unpackable]] = {}

    @classmethod
    def __call__(cls, name:str, msg_id:int):
        def _decorator(cls_):
            cls.name_to_id[name] = msg_id
            cls.id_to_type[msg_id] = cls_
            return cls_
        return _decorator

register = MessageRegister()

@dataclass
class MavlinkMessage(Unpackable):
    len_ : int = 0
    seq : int = 0
    sys_id : int = 0
    comp_id: int = 0
    msg_id : int = 0
    payload : Optional[Unpackable] = None

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<5B', data, offset)
        payload = register.id_to_type[args[4]].unpack(data[5:-2])
        return cls(*args, payload)


### Enumerations ###

class FIRMWARE_VERSION_TYPE(IntEnum):
    FIRMWARE_VERSION_TYPE_DEV = 0
    FIRMWARE_VERSION_TYPE_ALPHA = 64
    FIRMWARE_VERSION_TYPE_BETA = 128
    FIRMWARE_VERSION_TYPE_RC = 192
    FIRMWARE_VERSION_TYPE_OFFICIAL = 255

class HL_FAILURE_FLAG(IntEnum):
    HL_FAILURE_FLAG_GPS = 1
    HL_FAILURE_FLAG_DIFFERENTIAL_PRESSURE = 2
    HL_FAILURE_FLAG_ABSOLUTE_PRESSURE = 4
    HL_FAILURE_FLAG_3D_ACCEL = 8
    HL_FAILURE_FLAG_3D_GYRO = 16
    HL_FAILURE_FLAG_3D_MAG = 32
    HL_FAILURE_FLAG_TERRAIN = 64
    HL_FAILURE_FLAG_BATTERY = 128
    HL_FAILURE_FLAG_RC_RECEIVER = 256
    HL_FAILURE_FLAG_OFFBOARD_LINK = 512
    HL_FAILURE_FLAG_ENGINE = 1024
    HL_FAILURE_FLAG_GEOFENCE = 2048
    HL_FAILURE_FLAG_ESTIMATOR = 4096
    HL_FAILURE_FLAG_MISSION = 8192

class MAV_GOTO(IntEnum):
    MAV_GOTO_DO_HOLD = 0
    MAV_GOTO_DO_CONTINUE = 1
    MAV_GOTO_HOLD_AT_CURRENT_POSITION = 2
    MAV_GOTO_HOLD_AT_SPECIFIED_POSITION = 3

class MAV_MODE(IntEnum):
    MAV_MODE_PREFLIGHT = 0
    MAV_MODE_STABILIZE_DISARMED = 80
    MAV_MODE_STABILIZE_ARMED = 208
    MAV_MODE_MANUAL_DISARMED = 64
    MAV_MODE_MANUAL_ARMED = 192
    MAV_MODE_GUIDED_DISARMED = 88
    MAV_MODE_GUIDED_ARMED = 216
    MAV_MODE_AUTO_DISARMED = 92
    MAV_MODE_AUTO_ARMED = 220
    MAV_MODE_TEST_DISARMED = 66
    MAV_MODE_TEST_ARMED = 194

class MAV_SYS_STATUS_SENSOR(IntEnum):
    MAV_SYS_STATUS_SENSOR_3D_GYRO = 1
    MAV_SYS_STATUS_SENSOR_3D_ACCEL = 2
    MAV_SYS_STATUS_SENSOR_3D_MAG = 4
    MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE = 8
    MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE = 16
    MAV_SYS_STATUS_SENSOR_GPS = 32
    MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW = 64
    MAV_SYS_STATUS_SENSOR_VISION_POSITION = 128
    MAV_SYS_STATUS_SENSOR_LASER_POSITION = 256
    MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH = 512
    MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL = 1024
    MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION = 2048
    MAV_SYS_STATUS_SENSOR_YAW_POSITION = 4096
    MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL = 8192
    MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL = 16384
    MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS = 32768
    MAV_SYS_STATUS_SENSOR_RC_RECEIVER = 65536
    MAV_SYS_STATUS_SENSOR_3D_GYRO2 = 131072
    MAV_SYS_STATUS_SENSOR_3D_ACCEL2 = 262144
    MAV_SYS_STATUS_SENSOR_3D_MAG2 = 524288
    MAV_SYS_STATUS_GEOFENCE = 1048576
    MAV_SYS_STATUS_AHRS = 2097152
    MAV_SYS_STATUS_TERRAIN = 4194304
    MAV_SYS_STATUS_REVERSE_MOTOR = 8388608
    MAV_SYS_STATUS_LOGGING = 16777216
    MAV_SYS_STATUS_SENSOR_BATTERY = 33554432
    MAV_SYS_STATUS_SENSOR_PROXIMITY = 67108864
    MAV_SYS_STATUS_SENSOR_SATCOM = 134217728
    MAV_SYS_STATUS_PREARM_CHECK = 268435456
    MAV_SYS_STATUS_OBSTACLE_AVOIDANCE = 536870912
    MAV_SYS_STATUS_SENSOR_PROPULSION = 1073741824
    MAV_SYS_STATUS_EXTENSION_USED = 2147483648

class MAV_SYS_STATUS_SENSOR_EXTENDED(IntEnum):
    MAV_SYS_STATUS_RECOVERY_SYSTEM = 1

class MAV_FRAME(IntEnum):
    MAV_FRAME_GLOBAL = 0
    MAV_FRAME_LOCAL_NED = 1
    MAV_FRAME_MISSION = 2
    MAV_FRAME_GLOBAL_RELATIVE_ALT = 3
    MAV_FRAME_LOCAL_ENU = 4
    MAV_FRAME_GLOBAL_INT = 5
    MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6
    MAV_FRAME_LOCAL_OFFSET_NED = 7
    MAV_FRAME_BODY_NED = 8
    MAV_FRAME_BODY_OFFSET_NED = 9
    MAV_FRAME_GLOBAL_TERRAIN_ALT = 10
    MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
    MAV_FRAME_BODY_FRD = 12
    MAV_FRAME_RESERVED_13 = 13
    MAV_FRAME_RESERVED_14 = 14
    MAV_FRAME_RESERVED_15 = 15
    MAV_FRAME_RESERVED_16 = 16
    MAV_FRAME_RESERVED_17 = 17
    MAV_FRAME_RESERVED_18 = 18
    MAV_FRAME_RESERVED_19 = 19
    MAV_FRAME_LOCAL_FRD = 20
    MAV_FRAME_LOCAL_FLU = 21

class MAVLINK_DATA_STREAM_TYPE(IntEnum):
    MAVLINK_DATA_STREAM_IMG_JPEG = 0
    MAVLINK_DATA_STREAM_IMG_BMP = 1
    MAVLINK_DATA_STREAM_IMG_RAW8U = 2
    MAVLINK_DATA_STREAM_IMG_RAW32U = 3
    MAVLINK_DATA_STREAM_IMG_PGM = 4
    MAVLINK_DATA_STREAM_IMG_PNG = 5

class FENCE_ACTION(IntEnum):
    FENCE_ACTION_NONE = 0
    FENCE_ACTION_GUIDED = 1
    FENCE_ACTION_REPORT = 2
    FENCE_ACTION_GUIDED_THR_PASS = 3
    FENCE_ACTION_RTL = 4
    FENCE_ACTION_HOLD = 5
    FENCE_ACTION_TERMINATE = 6
    FENCE_ACTION_LAND = 7

class FENCE_BREACH(IntEnum):
    FENCE_BREACH_NONE = 0
    FENCE_BREACH_MINALT = 1
    FENCE_BREACH_MAXALT = 2
    FENCE_BREACH_BOUNDARY = 3

class FENCE_MITIGATE(IntEnum):
    FENCE_MITIGATE_UNKNOWN = 0
    FENCE_MITIGATE_NONE = 1
    FENCE_MITIGATE_VEL_LIMIT = 2

class FENCE_TYPE(IntEnum):
    FENCE_TYPE_ALL = 0
    FENCE_TYPE_ALT_MAX = 1
    FENCE_TYPE_CIRCLE = 2
    FENCE_TYPE_POLYGON = 4
    FENCE_TYPE_ALT_MIN = 8

class MAV_MOUNT_MODE(IntEnum):
    MAV_MOUNT_MODE_RETRACT = 0
    MAV_MOUNT_MODE_NEUTRAL = 1
    MAV_MOUNT_MODE_MAVLINK_TARGETING = 2
    MAV_MOUNT_MODE_RC_TARGETING = 3
    MAV_MOUNT_MODE_GPS_POINT = 4
    MAV_MOUNT_MODE_SYSID_TARGET = 5
    MAV_MOUNT_MODE_HOME_LOCATION = 6

class GIMBAL_DEVICE_CAP_FLAGS(IntEnum):
    GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT = 1
    GIMBAL_DEVICE_CAP_FLAGS_HAS_NEUTRAL = 2
    GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_AXIS = 4
    GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_FOLLOW = 8
    GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_LOCK = 16
    GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_AXIS = 32
    GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_FOLLOW = 64
    GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_LOCK = 128
    GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_AXIS = 256
    GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_FOLLOW = 512
    GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_LOCK = 1024
    GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_INFINITE_YAW = 2048
    GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME = 4096
    GIMBAL_DEVICE_CAP_FLAGS_HAS_RC_INPUTS = 8192

class GIMBAL_MANAGER_CAP_FLAGS(IntEnum):
    GIMBAL_MANAGER_CAP_FLAGS_HAS_RETRACT = 1
    GIMBAL_MANAGER_CAP_FLAGS_HAS_NEUTRAL = 2
    GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_AXIS = 4
    GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_FOLLOW = 8
    GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_LOCK = 16
    GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_AXIS = 32
    GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_FOLLOW = 64
    GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_LOCK = 128
    GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_AXIS = 256
    GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_FOLLOW = 512
    GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_LOCK = 1024
    GIMBAL_MANAGER_CAP_FLAGS_SUPPORTS_INFINITE_YAW = 2048
    GIMBAL_MANAGER_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME = 4096
    GIMBAL_MANAGER_CAP_FLAGS_HAS_RC_INPUTS = 8192
    GIMBAL_MANAGER_CAP_FLAGS_CAN_POINT_LOCATION_LOCAL = 65536
    GIMBAL_MANAGER_CAP_FLAGS_CAN_POINT_LOCATION_GLOBAL = 131072

class GIMBAL_DEVICE_FLAGS(IntEnum):
    GIMBAL_DEVICE_FLAGS_RETRACT = 1
    GIMBAL_DEVICE_FLAGS_NEUTRAL = 2
    GIMBAL_DEVICE_FLAGS_ROLL_LOCK = 4
    GIMBAL_DEVICE_FLAGS_PITCH_LOCK = 8
    GIMBAL_DEVICE_FLAGS_YAW_LOCK = 16
    GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME = 32
    GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME = 64
    GIMBAL_DEVICE_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME = 128
    GIMBAL_DEVICE_FLAGS_RC_EXCLUSIVE = 256
    GIMBAL_DEVICE_FLAGS_RC_MIXED = 512

class GIMBAL_MANAGER_FLAGS(IntEnum):
    GIMBAL_MANAGER_FLAGS_RETRACT = 1
    GIMBAL_MANAGER_FLAGS_NEUTRAL = 2
    GIMBAL_MANAGER_FLAGS_ROLL_LOCK = 4
    GIMBAL_MANAGER_FLAGS_PITCH_LOCK = 8
    GIMBAL_MANAGER_FLAGS_YAW_LOCK = 16
    GIMBAL_MANAGER_FLAGS_YAW_IN_VEHICLE_FRAME = 32
    GIMBAL_MANAGER_FLAGS_YAW_IN_EARTH_FRAME = 64
    GIMBAL_MANAGER_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME = 128
    GIMBAL_MANAGER_FLAGS_RC_EXCLUSIVE = 256
    GIMBAL_MANAGER_FLAGS_RC_MIXED = 512

class GIMBAL_DEVICE_ERROR_FLAGS(IntEnum):
    GIMBAL_DEVICE_ERROR_FLAGS_AT_ROLL_LIMIT = 1
    GIMBAL_DEVICE_ERROR_FLAGS_AT_PITCH_LIMIT = 2
    GIMBAL_DEVICE_ERROR_FLAGS_AT_YAW_LIMIT = 4
    GIMBAL_DEVICE_ERROR_FLAGS_ENCODER_ERROR = 8
    GIMBAL_DEVICE_ERROR_FLAGS_POWER_ERROR = 16
    GIMBAL_DEVICE_ERROR_FLAGS_MOTOR_ERROR = 32
    GIMBAL_DEVICE_ERROR_FLAGS_SOFTWARE_ERROR = 64
    GIMBAL_DEVICE_ERROR_FLAGS_COMMS_ERROR = 128
    GIMBAL_DEVICE_ERROR_FLAGS_CALIBRATION_RUNNING = 256
    GIMBAL_DEVICE_ERROR_FLAGS_NO_MANAGER = 512

class GRIPPER_ACTIONS(IntEnum):
    GRIPPER_ACTION_RELEASE = 0
    GRIPPER_ACTION_GRAB = 1

class WINCH_ACTIONS(IntEnum):
    WINCH_RELAXED = 0
    WINCH_RELATIVE_LENGTH_CONTROL = 1
    WINCH_RATE_CONTROL = 2
    WINCH_LOCK = 3
    WINCH_DELIVER = 4
    WINCH_HOLD = 5
    WINCH_RETRACT = 6
    WINCH_LOAD_LINE = 7
    WINCH_ABANDON_LINE = 8
    WINCH_LOAD_PAYLOAD = 9

class UAVCAN_NODE_HEALTH(IntEnum):
    UAVCAN_NODE_HEALTH_OK = 0
    UAVCAN_NODE_HEALTH_WARNING = 1
    UAVCAN_NODE_HEALTH_ERROR = 2
    UAVCAN_NODE_HEALTH_CRITICAL = 3

class UAVCAN_NODE_MODE(IntEnum):
    UAVCAN_NODE_MODE_OPERATIONAL = 0
    UAVCAN_NODE_MODE_INITIALIZATION = 1
    UAVCAN_NODE_MODE_MAINTENANCE = 2
    UAVCAN_NODE_MODE_SOFTWARE_UPDATE = 3
    UAVCAN_NODE_MODE_OFFLINE = 7

class ESC_CONNECTION_TYPE(IntEnum):
    ESC_CONNECTION_TYPE_PPM = 0
    ESC_CONNECTION_TYPE_SERIAL = 1
    ESC_CONNECTION_TYPE_ONESHOT = 2
    ESC_CONNECTION_TYPE_I2C = 3
    ESC_CONNECTION_TYPE_CAN = 4
    ESC_CONNECTION_TYPE_DSHOT = 5

class ESC_FAILURE_FLAGS(IntEnum):
    ESC_FAILURE_NONE = 0
    ESC_FAILURE_OVER_CURRENT = 1
    ESC_FAILURE_OVER_VOLTAGE = 2
    ESC_FAILURE_OVER_TEMPERATURE = 4
    ESC_FAILURE_OVER_RPM = 8
    ESC_FAILURE_INCONSISTENT_CMD = 16
    ESC_FAILURE_MOTOR_STUCK = 32
    ESC_FAILURE_GENERIC = 64

class STORAGE_STATUS(IntEnum):
    STORAGE_STATUS_EMPTY = 0
    STORAGE_STATUS_UNFORMATTED = 1
    STORAGE_STATUS_READY = 2
    STORAGE_STATUS_NOT_SUPPORTED = 3

class STORAGE_TYPE(IntEnum):
    STORAGE_TYPE_UNKNOWN = 0
    STORAGE_TYPE_USB_STICK = 1
    STORAGE_TYPE_SD = 2
    STORAGE_TYPE_MICROSD = 3
    STORAGE_TYPE_CF = 4
    STORAGE_TYPE_CFE = 5
    STORAGE_TYPE_XQD = 6
    STORAGE_TYPE_HD = 7
    STORAGE_TYPE_OTHER = 254

class STORAGE_USAGE_FLAG(IntEnum):
    STORAGE_USAGE_FLAG_SET = 1
    STORAGE_USAGE_FLAG_PHOTO = 2
    STORAGE_USAGE_FLAG_VIDEO = 4
    STORAGE_USAGE_FLAG_LOGS = 8

class ORBIT_YAW_BEHAVIOUR(IntEnum):
    ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TO_CIRCLE_CENTER = 0
    ORBIT_YAW_BEHAVIOUR_HOLD_INITIAL_HEADING = 1
    ORBIT_YAW_BEHAVIOUR_UNCONTROLLED = 2
    ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TANGENT_TO_CIRCLE = 3
    ORBIT_YAW_BEHAVIOUR_RC_CONTROLLED = 4
    ORBIT_YAW_BEHAVIOUR_UNCHANGED = 5

class WIFI_CONFIG_AP_RESPONSE(IntEnum):
    WIFI_CONFIG_AP_RESPONSE_UNDEFINED = 0
    WIFI_CONFIG_AP_RESPONSE_ACCEPTED = 1
    WIFI_CONFIG_AP_RESPONSE_REJECTED = 2
    WIFI_CONFIG_AP_RESPONSE_MODE_ERROR = 3
    WIFI_CONFIG_AP_RESPONSE_SSID_ERROR = 4
    WIFI_CONFIG_AP_RESPONSE_PASSWORD_ERROR = 5

class CELLULAR_CONFIG_RESPONSE(IntEnum):
    CELLULAR_CONFIG_RESPONSE_ACCEPTED = 0
    CELLULAR_CONFIG_RESPONSE_APN_ERROR = 1
    CELLULAR_CONFIG_RESPONSE_PIN_ERROR = 2
    CELLULAR_CONFIG_RESPONSE_REJECTED = 3
    CELLULAR_CONFIG_BLOCKED_PUK_REQUIRED = 4

class WIFI_CONFIG_AP_MODE(IntEnum):
    WIFI_CONFIG_AP_MODE_UNDEFINED = 0
    WIFI_CONFIG_AP_MODE_AP = 1
    WIFI_CONFIG_AP_MODE_STATION = 2
    WIFI_CONFIG_AP_MODE_DISABLED = 3

class COMP_METADATA_TYPE(IntEnum):
    COMP_METADATA_TYPE_GENERAL = 0
    COMP_METADATA_TYPE_PARAMETER = 1
    COMP_METADATA_TYPE_COMMANDS = 2
    COMP_METADATA_TYPE_PERIPHERALS = 3
    COMP_METADATA_TYPE_EVENTS = 4
    COMP_METADATA_TYPE_ACTUATORS = 5

class ACTUATOR_CONFIGURATION(IntEnum):
    ACTUATOR_CONFIGURATION_NONE = 0
    ACTUATOR_CONFIGURATION_BEEP = 1
    ACTUATOR_CONFIGURATION_3D_MODE_ON = 2
    ACTUATOR_CONFIGURATION_3D_MODE_OFF = 3
    ACTUATOR_CONFIGURATION_SPIN_DIRECTION1 = 4
    ACTUATOR_CONFIGURATION_SPIN_DIRECTION2 = 5

class ACTUATOR_OUTPUT_FUNCTION(IntEnum):
    ACTUATOR_OUTPUT_FUNCTION_NONE = 0
    ACTUATOR_OUTPUT_FUNCTION_MOTOR1 = 1
    ACTUATOR_OUTPUT_FUNCTION_MOTOR2 = 2
    ACTUATOR_OUTPUT_FUNCTION_MOTOR3 = 3
    ACTUATOR_OUTPUT_FUNCTION_MOTOR4 = 4
    ACTUATOR_OUTPUT_FUNCTION_MOTOR5 = 5
    ACTUATOR_OUTPUT_FUNCTION_MOTOR6 = 6
    ACTUATOR_OUTPUT_FUNCTION_MOTOR7 = 7
    ACTUATOR_OUTPUT_FUNCTION_MOTOR8 = 8
    ACTUATOR_OUTPUT_FUNCTION_MOTOR9 = 9
    ACTUATOR_OUTPUT_FUNCTION_MOTOR10 = 10
    ACTUATOR_OUTPUT_FUNCTION_MOTOR11 = 11
    ACTUATOR_OUTPUT_FUNCTION_MOTOR12 = 12
    ACTUATOR_OUTPUT_FUNCTION_MOTOR13 = 13
    ACTUATOR_OUTPUT_FUNCTION_MOTOR14 = 14
    ACTUATOR_OUTPUT_FUNCTION_MOTOR15 = 15
    ACTUATOR_OUTPUT_FUNCTION_MOTOR16 = 16
    ACTUATOR_OUTPUT_FUNCTION_SERVO1 = 33
    ACTUATOR_OUTPUT_FUNCTION_SERVO2 = 34
    ACTUATOR_OUTPUT_FUNCTION_SERVO3 = 35
    ACTUATOR_OUTPUT_FUNCTION_SERVO4 = 36
    ACTUATOR_OUTPUT_FUNCTION_SERVO5 = 37
    ACTUATOR_OUTPUT_FUNCTION_SERVO6 = 38
    ACTUATOR_OUTPUT_FUNCTION_SERVO7 = 39
    ACTUATOR_OUTPUT_FUNCTION_SERVO8 = 40
    ACTUATOR_OUTPUT_FUNCTION_SERVO9 = 41
    ACTUATOR_OUTPUT_FUNCTION_SERVO10 = 42
    ACTUATOR_OUTPUT_FUNCTION_SERVO11 = 43
    ACTUATOR_OUTPUT_FUNCTION_SERVO12 = 44
    ACTUATOR_OUTPUT_FUNCTION_SERVO13 = 45
    ACTUATOR_OUTPUT_FUNCTION_SERVO14 = 46
    ACTUATOR_OUTPUT_FUNCTION_SERVO15 = 47
    ACTUATOR_OUTPUT_FUNCTION_SERVO16 = 48

class AUTOTUNE_AXIS(IntEnum):
    AUTOTUNE_AXIS_DEFAULT = 0
    AUTOTUNE_AXIS_ROLL = 1
    AUTOTUNE_AXIS_PITCH = 2
    AUTOTUNE_AXIS_YAW = 4

class PREFLIGHT_STORAGE_PARAMETER_ACTION(IntEnum):
    PARAM_READ_PERSISTENT = 0
    PARAM_WRITE_PERSISTENT = 1
    PARAM_RESET_CONFIG_DEFAULT = 2
    PARAM_RESET_SENSOR_DEFAULT = 3
    PARAM_RESET_ALL_DEFAULT = 4

class PREFLIGHT_STORAGE_MISSION_ACTION(IntEnum):
    MISSION_READ_PERSISTENT = 0
    MISSION_WRITE_PERSISTENT = 1
    MISSION_RESET_DEFAULT = 2

class MAV_CMD(IntEnum):
    MAV_CMD_NAV_WAYPOINT = 16
    MAV_CMD_NAV_LOITER_UNLIM = 17
    MAV_CMD_NAV_LOITER_TURNS = 18
    MAV_CMD_NAV_LOITER_TIME = 19
    MAV_CMD_NAV_RETURN_TO_LAUNCH = 20
    MAV_CMD_NAV_LAND = 21
    MAV_CMD_NAV_TAKEOFF = 22
    MAV_CMD_NAV_LAND_LOCAL = 23
    MAV_CMD_NAV_TAKEOFF_LOCAL = 24
    MAV_CMD_NAV_FOLLOW = 25
    MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT = 30
    MAV_CMD_NAV_LOITER_TO_ALT = 31
    MAV_CMD_DO_FOLLOW = 32
    MAV_CMD_DO_FOLLOW_REPOSITION = 33
    MAV_CMD_DO_ORBIT = 34
    MAV_CMD_NAV_ROI = 80
    MAV_CMD_NAV_PATHPLANNING = 81
    MAV_CMD_NAV_SPLINE_WAYPOINT = 82
    MAV_CMD_NAV_VTOL_TAKEOFF = 84
    MAV_CMD_NAV_VTOL_LAND = 85
    MAV_CMD_NAV_GUIDED_ENABLE = 92
    MAV_CMD_NAV_DELAY = 93
    MAV_CMD_NAV_PAYLOAD_PLACE = 94
    MAV_CMD_NAV_LAST = 95
    MAV_CMD_CONDITION_DELAY = 112
    MAV_CMD_CONDITION_CHANGE_ALT = 113
    MAV_CMD_CONDITION_DISTANCE = 114
    MAV_CMD_CONDITION_YAW = 115
    MAV_CMD_CONDITION_LAST = 159
    MAV_CMD_DO_SET_MODE = 176
    MAV_CMD_DO_JUMP = 177
    MAV_CMD_DO_CHANGE_SPEED = 178
    MAV_CMD_DO_SET_HOME = 179
    MAV_CMD_DO_SET_PARAMETER = 180
    MAV_CMD_DO_SET_RELAY = 181
    MAV_CMD_DO_REPEAT_RELAY = 182
    MAV_CMD_DO_SET_SERVO = 183
    MAV_CMD_DO_REPEAT_SERVO = 184
    MAV_CMD_DO_FLIGHTTERMINATION = 185
    MAV_CMD_DO_CHANGE_ALTITUDE = 186
    MAV_CMD_DO_SET_ACTUATOR = 187
    MAV_CMD_DO_RETURN_PATH_START = 188
    MAV_CMD_DO_LAND_START = 189
    MAV_CMD_DO_RALLY_LAND = 190
    MAV_CMD_DO_GO_AROUND = 191
    MAV_CMD_DO_REPOSITION = 192
    MAV_CMD_DO_PAUSE_CONTINUE = 193
    MAV_CMD_DO_SET_REVERSE = 194
    MAV_CMD_DO_SET_ROI_LOCATION = 195
    MAV_CMD_DO_SET_ROI_WPNEXT_OFFSET = 196
    MAV_CMD_DO_SET_ROI_NONE = 197
    MAV_CMD_DO_SET_ROI_SYSID = 198
    MAV_CMD_DO_CONTROL_VIDEO = 200
    MAV_CMD_DO_SET_ROI = 201
    MAV_CMD_DO_DIGICAM_CONFIGURE = 202
    MAV_CMD_DO_DIGICAM_CONTROL = 203
    MAV_CMD_DO_MOUNT_CONFIGURE = 204
    MAV_CMD_DO_MOUNT_CONTROL = 205
    MAV_CMD_DO_SET_CAM_TRIGG_DIST = 206
    MAV_CMD_DO_FENCE_ENABLE = 207
    MAV_CMD_DO_PARACHUTE = 208
    MAV_CMD_DO_MOTOR_TEST = 209
    MAV_CMD_DO_INVERTED_FLIGHT = 210
    MAV_CMD_DO_GRIPPER = 211
    MAV_CMD_DO_AUTOTUNE_ENABLE = 212
    MAV_CMD_NAV_SET_YAW_SPEED = 213
    MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL = 214
    MAV_CMD_DO_MOUNT_CONTROL_QUAT = 220
    MAV_CMD_DO_GUIDED_MASTER = 221
    MAV_CMD_DO_GUIDED_LIMITS = 222
    MAV_CMD_DO_ENGINE_CONTROL = 223
    MAV_CMD_DO_SET_MISSION_CURRENT = 224
    MAV_CMD_DO_LAST = 240
    MAV_CMD_PREFLIGHT_CALIBRATION = 241
    MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS = 242
    MAV_CMD_PREFLIGHT_UAVCAN = 243
    MAV_CMD_PREFLIGHT_STORAGE = 245
    MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN = 246
    MAV_CMD_OVERRIDE_GOTO = 252
    MAV_CMD_OBLIQUE_SURVEY = 260
    MAV_CMD_MISSION_START = 300
    MAV_CMD_ACTUATOR_TEST = 310
    MAV_CMD_CONFIGURE_ACTUATOR = 311
    MAV_CMD_COMPONENT_ARM_DISARM = 400
    MAV_CMD_RUN_PREARM_CHECKS = 401
    MAV_CMD_ILLUMINATOR_ON_OFF = 405
    MAV_CMD_DO_ILLUMINATOR_CONFIGURE = 406
    MAV_CMD_GET_HOME_POSITION = 410
    MAV_CMD_INJECT_FAILURE = 420
    MAV_CMD_START_RX_PAIR = 500
    MAV_CMD_GET_MESSAGE_INTERVAL = 510
    MAV_CMD_SET_MESSAGE_INTERVAL = 511
    MAV_CMD_REQUEST_MESSAGE = 512
    MAV_CMD_REQUEST_PROTOCOL_VERSION = 519
    MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES = 520
    MAV_CMD_REQUEST_CAMERA_INFORMATION = 521
    MAV_CMD_REQUEST_CAMERA_SETTINGS = 522
    MAV_CMD_REQUEST_STORAGE_INFORMATION = 525
    MAV_CMD_STORAGE_FORMAT = 526
    MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS = 527
    MAV_CMD_REQUEST_FLIGHT_INFORMATION = 528
    MAV_CMD_RESET_CAMERA_SETTINGS = 529
    MAV_CMD_SET_CAMERA_MODE = 530
    MAV_CMD_SET_CAMERA_ZOOM = 531
    MAV_CMD_SET_CAMERA_FOCUS = 532
    MAV_CMD_SET_STORAGE_USAGE = 533
    MAV_CMD_SET_CAMERA_SOURCE = 534
    MAV_CMD_JUMP_TAG = 600
    MAV_CMD_DO_JUMP_TAG = 601
    MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW = 1000
    MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE = 1001
    MAV_CMD_IMAGE_START_CAPTURE = 2000
    MAV_CMD_IMAGE_STOP_CAPTURE = 2001
    MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE = 2002
    MAV_CMD_DO_TRIGGER_CONTROL = 2003
    MAV_CMD_CAMERA_TRACK_POINT = 2004
    MAV_CMD_CAMERA_TRACK_RECTANGLE = 2005
    MAV_CMD_CAMERA_STOP_TRACKING = 2010
    MAV_CMD_VIDEO_START_CAPTURE = 2500
    MAV_CMD_VIDEO_STOP_CAPTURE = 2501
    MAV_CMD_VIDEO_START_STREAMING = 2502
    MAV_CMD_VIDEO_STOP_STREAMING = 2503
    MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION = 2504
    MAV_CMD_REQUEST_VIDEO_STREAM_STATUS = 2505
    MAV_CMD_LOGGING_START = 2510
    MAV_CMD_LOGGING_STOP = 2511
    MAV_CMD_AIRFRAME_CONFIGURATION = 2520
    MAV_CMD_CONTROL_HIGH_LATENCY = 2600
    MAV_CMD_PANORAMA_CREATE = 2800
    MAV_CMD_DO_VTOL_TRANSITION = 3000
    MAV_CMD_ARM_AUTHORIZATION_REQUEST = 3001
    MAV_CMD_SET_GUIDED_SUBMODE_STANDARD = 4000
    MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE = 4001
    MAV_CMD_CONDITION_GATE = 4501
    MAV_CMD_NAV_FENCE_RETURN_POINT = 5000
    MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION = 5001
    MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION = 5002
    MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION = 5003
    MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION = 5004
    MAV_CMD_NAV_RALLY_POINT = 5100
    MAV_CMD_UAVCAN_GET_NODE_INFO = 5200
    MAV_CMD_DO_SET_SAFETY_SWITCH_STATE = 5300
    MAV_CMD_DO_ADSB_OUT_IDENT = 10001
    MAV_CMD_PAYLOAD_PREPARE_DEPLOY = 30001
    MAV_CMD_PAYLOAD_CONTROL_DEPLOY = 30002
    MAV_CMD_FIXED_MAG_CAL_YAW = 42006
    MAV_CMD_DO_WINCH = 42600
    MAV_CMD_EXTERNAL_POSITION_ESTIMATE = 43003
    MAV_CMD_WAYPOINT_USER_1 = 31000
    MAV_CMD_WAYPOINT_USER_2 = 31001
    MAV_CMD_WAYPOINT_USER_3 = 31002
    MAV_CMD_WAYPOINT_USER_4 = 31003
    MAV_CMD_WAYPOINT_USER_5 = 31004
    MAV_CMD_SPATIAL_USER_1 = 31005
    MAV_CMD_SPATIAL_USER_2 = 31006
    MAV_CMD_SPATIAL_USER_3 = 31007
    MAV_CMD_SPATIAL_USER_4 = 31008
    MAV_CMD_SPATIAL_USER_5 = 31009
    MAV_CMD_USER_1 = 31010
    MAV_CMD_USER_2 = 31011
    MAV_CMD_USER_3 = 31012
    MAV_CMD_USER_4 = 31013
    MAV_CMD_USER_5 = 31014
    MAV_CMD_CAN_FORWARD = 32000

class MAV_DATA_STREAM(IntEnum):
    MAV_DATA_STREAM_ALL = 0
    MAV_DATA_STREAM_RAW_SENSORS = 1
    MAV_DATA_STREAM_EXTENDED_STATUS = 2
    MAV_DATA_STREAM_RC_CHANNELS = 3
    MAV_DATA_STREAM_RAW_CONTROLLER = 4
    MAV_DATA_STREAM_POSITION = 6
    MAV_DATA_STREAM_EXTRA1 = 10
    MAV_DATA_STREAM_EXTRA2 = 11
    MAV_DATA_STREAM_EXTRA3 = 12

class MAV_ROI(IntEnum):
    MAV_ROI_NONE = 0
    MAV_ROI_WPNEXT = 1
    MAV_ROI_WPINDEX = 2
    MAV_ROI_LOCATION = 3
    MAV_ROI_TARGET = 4

class MAV_PARAM_TYPE(IntEnum):
    MAV_PARAM_TYPE_UINT8 = 1
    MAV_PARAM_TYPE_INT8 = 2
    MAV_PARAM_TYPE_UINT16 = 3
    MAV_PARAM_TYPE_INT16 = 4
    MAV_PARAM_TYPE_UINT32 = 5
    MAV_PARAM_TYPE_INT32 = 6
    MAV_PARAM_TYPE_UINT64 = 7
    MAV_PARAM_TYPE_INT64 = 8
    MAV_PARAM_TYPE_REAL32 = 9
    MAV_PARAM_TYPE_REAL64 = 10

class MAV_PARAM_EXT_TYPE(IntEnum):
    MAV_PARAM_EXT_TYPE_UINT8 = 1
    MAV_PARAM_EXT_TYPE_INT8 = 2
    MAV_PARAM_EXT_TYPE_UINT16 = 3
    MAV_PARAM_EXT_TYPE_INT16 = 4
    MAV_PARAM_EXT_TYPE_UINT32 = 5
    MAV_PARAM_EXT_TYPE_INT32 = 6
    MAV_PARAM_EXT_TYPE_UINT64 = 7
    MAV_PARAM_EXT_TYPE_INT64 = 8
    MAV_PARAM_EXT_TYPE_REAL32 = 9
    MAV_PARAM_EXT_TYPE_REAL64 = 10
    MAV_PARAM_EXT_TYPE_CUSTOM = 11

class MAV_RESULT(IntEnum):
    MAV_RESULT_ACCEPTED = 0
    MAV_RESULT_TEMPORARILY_REJECTED = 1
    MAV_RESULT_DENIED = 2
    MAV_RESULT_UNSUPPORTED = 3
    MAV_RESULT_FAILED = 4
    MAV_RESULT_IN_PROGRESS = 5
    MAV_RESULT_CANCELLED = 6
    MAV_RESULT_COMMAND_LONG_ONLY = 7
    MAV_RESULT_COMMAND_INT_ONLY = 8
    MAV_RESULT_COMMAND_UNSUPPORTED_MAV_FRAME = 9

class MAV_MISSION_RESULT(IntEnum):
    MAV_MISSION_ACCEPTED = 0
    MAV_MISSION_ERROR = 1
    MAV_MISSION_UNSUPPORTED_FRAME = 2
    MAV_MISSION_UNSUPPORTED = 3
    MAV_MISSION_NO_SPACE = 4
    MAV_MISSION_INVALID = 5
    MAV_MISSION_INVALID_PARAM1 = 6
    MAV_MISSION_INVALID_PARAM2 = 7
    MAV_MISSION_INVALID_PARAM3 = 8
    MAV_MISSION_INVALID_PARAM4 = 9
    MAV_MISSION_INVALID_PARAM5_X = 10
    MAV_MISSION_INVALID_PARAM6_Y = 11
    MAV_MISSION_INVALID_PARAM7 = 12
    MAV_MISSION_INVALID_SEQUENCE = 13
    MAV_MISSION_DENIED = 14
    MAV_MISSION_OPERATION_CANCELLED = 15

class MAV_SEVERITY(IntEnum):
    MAV_SEVERITY_EMERGENCY = 0
    MAV_SEVERITY_ALERT = 1
    MAV_SEVERITY_CRITICAL = 2
    MAV_SEVERITY_ERROR = 3
    MAV_SEVERITY_WARNING = 4
    MAV_SEVERITY_NOTICE = 5
    MAV_SEVERITY_INFO = 6
    MAV_SEVERITY_DEBUG = 7

class MAV_POWER_STATUS(IntEnum):
    MAV_POWER_STATUS_BRICK_VALID = 1
    MAV_POWER_STATUS_SERVO_VALID = 2
    MAV_POWER_STATUS_USB_CONNECTED = 4
    MAV_POWER_STATUS_PERIPH_OVERCURRENT = 8
    MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT = 16
    MAV_POWER_STATUS_CHANGED = 32

class SERIAL_CONTROL_DEV(IntEnum):
    SERIAL_CONTROL_DEV_TELEM1 = 0
    SERIAL_CONTROL_DEV_TELEM2 = 1
    SERIAL_CONTROL_DEV_GPS1 = 2
    SERIAL_CONTROL_DEV_GPS2 = 3
    SERIAL_CONTROL_DEV_SHELL = 10
    SERIAL_CONTROL_SERIAL0 = 100
    SERIAL_CONTROL_SERIAL1 = 101
    SERIAL_CONTROL_SERIAL2 = 102
    SERIAL_CONTROL_SERIAL3 = 103
    SERIAL_CONTROL_SERIAL4 = 104
    SERIAL_CONTROL_SERIAL5 = 105
    SERIAL_CONTROL_SERIAL6 = 106
    SERIAL_CONTROL_SERIAL7 = 107
    SERIAL_CONTROL_SERIAL8 = 108
    SERIAL_CONTROL_SERIAL9 = 109

class SERIAL_CONTROL_FLAG(IntEnum):
    SERIAL_CONTROL_FLAG_REPLY = 1
    SERIAL_CONTROL_FLAG_RESPOND = 2
    SERIAL_CONTROL_FLAG_EXCLUSIVE = 4
    SERIAL_CONTROL_FLAG_BLOCKING = 8
    SERIAL_CONTROL_FLAG_MULTI = 16

class MAV_DISTANCE_SENSOR(IntEnum):
    MAV_DISTANCE_SENSOR_LASER = 0
    MAV_DISTANCE_SENSOR_ULTRASOUND = 1
    MAV_DISTANCE_SENSOR_INFRARED = 2
    MAV_DISTANCE_SENSOR_RADAR = 3
    MAV_DISTANCE_SENSOR_UNKNOWN = 4

class MAV_SENSOR_ORIENTATION(IntEnum):
    MAV_SENSOR_ROTATION_NONE = 0
    MAV_SENSOR_ROTATION_YAW_45 = 1
    MAV_SENSOR_ROTATION_YAW_90 = 2
    MAV_SENSOR_ROTATION_YAW_135 = 3
    MAV_SENSOR_ROTATION_YAW_180 = 4
    MAV_SENSOR_ROTATION_YAW_225 = 5
    MAV_SENSOR_ROTATION_YAW_270 = 6
    MAV_SENSOR_ROTATION_YAW_315 = 7
    MAV_SENSOR_ROTATION_ROLL_180 = 8
    MAV_SENSOR_ROTATION_ROLL_180_YAW_45 = 9
    MAV_SENSOR_ROTATION_ROLL_180_YAW_90 = 10
    MAV_SENSOR_ROTATION_ROLL_180_YAW_135 = 11
    MAV_SENSOR_ROTATION_PITCH_180 = 12
    MAV_SENSOR_ROTATION_ROLL_180_YAW_225 = 13
    MAV_SENSOR_ROTATION_ROLL_180_YAW_270 = 14
    MAV_SENSOR_ROTATION_ROLL_180_YAW_315 = 15
    MAV_SENSOR_ROTATION_ROLL_90 = 16
    MAV_SENSOR_ROTATION_ROLL_90_YAW_45 = 17
    MAV_SENSOR_ROTATION_ROLL_90_YAW_90 = 18
    MAV_SENSOR_ROTATION_ROLL_90_YAW_135 = 19
    MAV_SENSOR_ROTATION_ROLL_270 = 20
    MAV_SENSOR_ROTATION_ROLL_270_YAW_45 = 21
    MAV_SENSOR_ROTATION_ROLL_270_YAW_90 = 22
    MAV_SENSOR_ROTATION_ROLL_270_YAW_135 = 23
    MAV_SENSOR_ROTATION_PITCH_90 = 24
    MAV_SENSOR_ROTATION_PITCH_270 = 25
    MAV_SENSOR_ROTATION_PITCH_180_YAW_90 = 26
    MAV_SENSOR_ROTATION_PITCH_180_YAW_270 = 27
    MAV_SENSOR_ROTATION_ROLL_90_PITCH_90 = 28
    MAV_SENSOR_ROTATION_ROLL_180_PITCH_90 = 29
    MAV_SENSOR_ROTATION_ROLL_270_PITCH_90 = 30
    MAV_SENSOR_ROTATION_ROLL_90_PITCH_180 = 31
    MAV_SENSOR_ROTATION_ROLL_270_PITCH_180 = 32
    MAV_SENSOR_ROTATION_ROLL_90_PITCH_270 = 33
    MAV_SENSOR_ROTATION_ROLL_180_PITCH_270 = 34
    MAV_SENSOR_ROTATION_ROLL_270_PITCH_270 = 35
    MAV_SENSOR_ROTATION_ROLL_90_PITCH_180_YAW_90 = 36
    MAV_SENSOR_ROTATION_ROLL_90_YAW_270 = 37
    MAV_SENSOR_ROTATION_ROLL_90_PITCH_68_YAW_293 = 38
    MAV_SENSOR_ROTATION_PITCH_315 = 39
    MAV_SENSOR_ROTATION_ROLL_90_PITCH_315 = 40
    MAV_SENSOR_ROTATION_CUSTOM = 100

class MAV_PROTOCOL_CAPABILITY(IntEnum):
    MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT = 1
    MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT = 2
    MAV_PROTOCOL_CAPABILITY_MISSION_INT = 4
    MAV_PROTOCOL_CAPABILITY_COMMAND_INT = 8
    MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_BYTEWISE = 16
    MAV_PROTOCOL_CAPABILITY_FTP = 32
    MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET = 64
    MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED = 128
    MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT = 256
    MAV_PROTOCOL_CAPABILITY_TERRAIN = 512
    MAV_PROTOCOL_CAPABILITY_RESERVED3 = 1024
    MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION = 2048
    MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION = 4096
    MAV_PROTOCOL_CAPABILITY_MAVLINK2 = 8192
    MAV_PROTOCOL_CAPABILITY_MISSION_FENCE = 16384
    MAV_PROTOCOL_CAPABILITY_MISSION_RALLY = 32768
    MAV_PROTOCOL_CAPABILITY_RESERVED2 = 65536
    MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_C_CAST = 131072
    MAV_PROTOCOL_CAPABILITY_COMPONENT_IMPLEMENTS_GIMBAL_MANAGER = 262144
    MAV_PROTOCOL_CAPABILITY_COMPONENT_ACCEPTS_GCS_CONTROL = 524288

class MAV_MISSION_TYPE(IntEnum):
    MAV_MISSION_TYPE_MISSION = 0
    MAV_MISSION_TYPE_FENCE = 1
    MAV_MISSION_TYPE_RALLY = 2
    MAV_MISSION_TYPE_ALL = 255

class MAV_ESTIMATOR_TYPE(IntEnum):
    MAV_ESTIMATOR_TYPE_UNKNOWN = 0
    MAV_ESTIMATOR_TYPE_NAIVE = 1
    MAV_ESTIMATOR_TYPE_VISION = 2
    MAV_ESTIMATOR_TYPE_VIO = 3
    MAV_ESTIMATOR_TYPE_GPS = 4
    MAV_ESTIMATOR_TYPE_GPS_INS = 5
    MAV_ESTIMATOR_TYPE_MOCAP = 6
    MAV_ESTIMATOR_TYPE_LIDAR = 7
    MAV_ESTIMATOR_TYPE_AUTOPILOT = 8

class MAV_BATTERY_TYPE(IntEnum):
    MAV_BATTERY_TYPE_UNKNOWN = 0
    MAV_BATTERY_TYPE_LIPO = 1
    MAV_BATTERY_TYPE_LIFE = 2
    MAV_BATTERY_TYPE_LION = 3
    MAV_BATTERY_TYPE_NIMH = 4

class MAV_BATTERY_FUNCTION(IntEnum):
    MAV_BATTERY_FUNCTION_UNKNOWN = 0
    MAV_BATTERY_FUNCTION_ALL = 1
    MAV_BATTERY_FUNCTION_PROPULSION = 2
    MAV_BATTERY_FUNCTION_AVIONICS = 3
    MAV_BATTERY_FUNCTION_PAYLOAD = 4

class MAV_BATTERY_CHARGE_STATE(IntEnum):
    MAV_BATTERY_CHARGE_STATE_UNDEFINED = 0
    MAV_BATTERY_CHARGE_STATE_OK = 1
    MAV_BATTERY_CHARGE_STATE_LOW = 2
    MAV_BATTERY_CHARGE_STATE_CRITICAL = 3
    MAV_BATTERY_CHARGE_STATE_EMERGENCY = 4
    MAV_BATTERY_CHARGE_STATE_FAILED = 5
    MAV_BATTERY_CHARGE_STATE_UNHEALTHY = 6
    MAV_BATTERY_CHARGE_STATE_CHARGING = 7

class MAV_BATTERY_MODE(IntEnum):
    MAV_BATTERY_MODE_UNKNOWN = 0
    MAV_BATTERY_MODE_AUTO_DISCHARGING = 1
    MAV_BATTERY_MODE_HOT_SWAP = 2

class MAV_BATTERY_FAULT(IntEnum):
    MAV_BATTERY_FAULT_DEEP_DISCHARGE = 1
    MAV_BATTERY_FAULT_SPIKES = 2
    MAV_BATTERY_FAULT_CELL_FAIL = 4
    MAV_BATTERY_FAULT_OVER_CURRENT = 8
    MAV_BATTERY_FAULT_OVER_TEMPERATURE = 16
    MAV_BATTERY_FAULT_UNDER_TEMPERATURE = 32
    MAV_BATTERY_FAULT_INCOMPATIBLE_VOLTAGE = 64
    MAV_BATTERY_FAULT_INCOMPATIBLE_FIRMWARE = 128
    BATTERY_FAULT_INCOMPATIBLE_CELLS_CONFIGURATION = 256

class MAV_FUEL_TYPE(IntEnum):
    MAV_FUEL_TYPE_UNKNOWN = 0
    MAV_FUEL_TYPE_LIQUID = 1
    MAV_FUEL_TYPE_GAS = 2

class MAV_GENERATOR_STATUS_FLAG(IntEnum):
    MAV_GENERATOR_STATUS_FLAG_OFF = 1
    MAV_GENERATOR_STATUS_FLAG_READY = 2
    MAV_GENERATOR_STATUS_FLAG_GENERATING = 4
    MAV_GENERATOR_STATUS_FLAG_CHARGING = 8
    MAV_GENERATOR_STATUS_FLAG_REDUCED_POWER = 16
    MAV_GENERATOR_STATUS_FLAG_MAXPOWER = 32
    MAV_GENERATOR_STATUS_FLAG_OVERTEMP_WARNING = 64
    MAV_GENERATOR_STATUS_FLAG_OVERTEMP_FAULT = 128
    MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_OVERTEMP_WARNING = 256
    MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_OVERTEMP_FAULT = 512
    MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_FAULT = 1024
    MAV_GENERATOR_STATUS_FLAG_POWERSOURCE_FAULT = 2048
    MAV_GENERATOR_STATUS_FLAG_COMMUNICATION_WARNING = 4096
    MAV_GENERATOR_STATUS_FLAG_COOLING_WARNING = 8192
    MAV_GENERATOR_STATUS_FLAG_POWER_RAIL_FAULT = 16384
    MAV_GENERATOR_STATUS_FLAG_OVERCURRENT_FAULT = 32768
    MAV_GENERATOR_STATUS_FLAG_BATTERY_OVERCHARGE_CURRENT_FAULT = 65536
    MAV_GENERATOR_STATUS_FLAG_OVERVOLTAGE_FAULT = 131072
    MAV_GENERATOR_STATUS_FLAG_BATTERY_UNDERVOLT_FAULT = 262144
    MAV_GENERATOR_STATUS_FLAG_START_INHIBITED = 524288
    MAV_GENERATOR_STATUS_FLAG_MAINTENANCE_REQUIRED = 1048576
    MAV_GENERATOR_STATUS_FLAG_WARMING_UP = 2097152
    MAV_GENERATOR_STATUS_FLAG_IDLE = 4194304

class MAV_VTOL_STATE(IntEnum):
    MAV_VTOL_STATE_UNDEFINED = 0
    MAV_VTOL_STATE_TRANSITION_TO_FW = 1
    MAV_VTOL_STATE_TRANSITION_TO_MC = 2
    MAV_VTOL_STATE_MC = 3
    MAV_VTOL_STATE_FW = 4

class MAV_LANDED_STATE(IntEnum):
    MAV_LANDED_STATE_UNDEFINED = 0
    MAV_LANDED_STATE_ON_GROUND = 1
    MAV_LANDED_STATE_IN_AIR = 2
    MAV_LANDED_STATE_TAKEOFF = 3
    MAV_LANDED_STATE_LANDING = 4

class ADSB_ALTITUDE_TYPE(IntEnum):
    ADSB_ALTITUDE_TYPE_PRESSURE_QNH = 0
    ADSB_ALTITUDE_TYPE_GEOMETRIC = 1

class ADSB_EMITTER_TYPE(IntEnum):
    ADSB_EMITTER_TYPE_NO_INFO = 0
    ADSB_EMITTER_TYPE_LIGHT = 1
    ADSB_EMITTER_TYPE_SMALL = 2
    ADSB_EMITTER_TYPE_LARGE = 3
    ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE = 4
    ADSB_EMITTER_TYPE_HEAVY = 5
    ADSB_EMITTER_TYPE_HIGHLY_MANUV = 6
    ADSB_EMITTER_TYPE_ROTOCRAFT = 7
    ADSB_EMITTER_TYPE_UNASSIGNED = 8
    ADSB_EMITTER_TYPE_GLIDER = 9
    ADSB_EMITTER_TYPE_LIGHTER_AIR = 10
    ADSB_EMITTER_TYPE_PARACHUTE = 11
    ADSB_EMITTER_TYPE_ULTRA_LIGHT = 12
    ADSB_EMITTER_TYPE_UNASSIGNED2 = 13
    ADSB_EMITTER_TYPE_UAV = 14
    ADSB_EMITTER_TYPE_SPACE = 15
    ADSB_EMITTER_TYPE_UNASSGINED3 = 16
    ADSB_EMITTER_TYPE_EMERGENCY_SURFACE = 17
    ADSB_EMITTER_TYPE_SERVICE_SURFACE = 18
    ADSB_EMITTER_TYPE_POINT_OBSTACLE = 19

class ADSB_FLAGS(IntEnum):
    ADSB_FLAGS_VALID_COORDS = 1
    ADSB_FLAGS_VALID_ALTITUDE = 2
    ADSB_FLAGS_VALID_HEADING = 4
    ADSB_FLAGS_VALID_VELOCITY = 8
    ADSB_FLAGS_VALID_CALLSIGN = 16
    ADSB_FLAGS_VALID_SQUAWK = 32
    ADSB_FLAGS_SIMULATED = 64
    ADSB_FLAGS_VERTICAL_VELOCITY_VALID = 128
    ADSB_FLAGS_BARO_VALID = 256
    ADSB_FLAGS_SOURCE_UAT = 32768

class MAV_DO_REPOSITION_FLAGS(IntEnum):
    MAV_DO_REPOSITION_FLAGS_CHANGE_MODE = 1

class SPEED_TYPE(IntEnum):
    SPEED_TYPE_AIRSPEED = 0
    SPEED_TYPE_GROUNDSPEED = 1
    SPEED_TYPE_CLIMB_SPEED = 2
    SPEED_TYPE_DESCENT_SPEED = 3

class ESTIMATOR_STATUS_FLAGS(IntEnum):
    ESTIMATOR_ATTITUDE = 1
    ESTIMATOR_VELOCITY_HORIZ = 2
    ESTIMATOR_VELOCITY_VERT = 4
    ESTIMATOR_POS_HORIZ_REL = 8
    ESTIMATOR_POS_HORIZ_ABS = 16
    ESTIMATOR_POS_VERT_ABS = 32
    ESTIMATOR_POS_VERT_AGL = 64
    ESTIMATOR_CONST_POS_MODE = 128
    ESTIMATOR_PRED_POS_HORIZ_REL = 256
    ESTIMATOR_PRED_POS_HORIZ_ABS = 512
    ESTIMATOR_GPS_GLITCH = 1024
    ESTIMATOR_ACCEL_ERROR = 2048

class MOTOR_TEST_ORDER(IntEnum):
    MOTOR_TEST_ORDER_DEFAULT = 0
    MOTOR_TEST_ORDER_SEQUENCE = 1
    MOTOR_TEST_ORDER_BOARD = 2

class MOTOR_TEST_THROTTLE_TYPE(IntEnum):
    MOTOR_TEST_THROTTLE_PERCENT = 0
    MOTOR_TEST_THROTTLE_PWM = 1
    MOTOR_TEST_THROTTLE_PILOT = 2
    MOTOR_TEST_COMPASS_CAL = 3

class GPS_INPUT_IGNORE_FLAGS(IntEnum):
    GPS_INPUT_IGNORE_FLAG_ALT = 1
    GPS_INPUT_IGNORE_FLAG_HDOP = 2
    GPS_INPUT_IGNORE_FLAG_VDOP = 4
    GPS_INPUT_IGNORE_FLAG_VEL_HORIZ = 8
    GPS_INPUT_IGNORE_FLAG_VEL_VERT = 16
    GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY = 32
    GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY = 64
    GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY = 128

class MAV_COLLISION_ACTION(IntEnum):
    MAV_COLLISION_ACTION_NONE = 0
    MAV_COLLISION_ACTION_REPORT = 1
    MAV_COLLISION_ACTION_ASCEND_OR_DESCEND = 2
    MAV_COLLISION_ACTION_MOVE_HORIZONTALLY = 3
    MAV_COLLISION_ACTION_MOVE_PERPENDICULAR = 4
    MAV_COLLISION_ACTION_RTL = 5
    MAV_COLLISION_ACTION_HOVER = 6

class MAV_COLLISION_THREAT_LEVEL(IntEnum):
    MAV_COLLISION_THREAT_LEVEL_NONE = 0
    MAV_COLLISION_THREAT_LEVEL_LOW = 1
    MAV_COLLISION_THREAT_LEVEL_HIGH = 2

class MAV_COLLISION_SRC(IntEnum):
    MAV_COLLISION_SRC_ADSB = 0
    MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT = 1

class GPS_FIX_TYPE(IntEnum):
    GPS_FIX_TYPE_NO_GPS = 0
    GPS_FIX_TYPE_NO_FIX = 1
    GPS_FIX_TYPE_2D_FIX = 2
    GPS_FIX_TYPE_3D_FIX = 3
    GPS_FIX_TYPE_DGPS = 4
    GPS_FIX_TYPE_RTK_FLOAT = 5
    GPS_FIX_TYPE_RTK_FIXED = 6
    GPS_FIX_TYPE_STATIC = 7
    GPS_FIX_TYPE_PPP = 8

class RTK_BASELINE_COORDINATE_SYSTEM(IntEnum):
    RTK_BASELINE_COORDINATE_SYSTEM_ECEF = 0
    RTK_BASELINE_COORDINATE_SYSTEM_NED = 1

class LANDING_TARGET_TYPE(IntEnum):
    LANDING_TARGET_TYPE_LIGHT_BEACON = 0
    LANDING_TARGET_TYPE_RADIO_BEACON = 1
    LANDING_TARGET_TYPE_VISION_FIDUCIAL = 2
    LANDING_TARGET_TYPE_VISION_OTHER = 3

class VTOL_TRANSITION_HEADING(IntEnum):
    VTOL_TRANSITION_HEADING_VEHICLE_DEFAULT = 0
    VTOL_TRANSITION_HEADING_NEXT_WAYPOINT = 1
    VTOL_TRANSITION_HEADING_TAKEOFF = 2
    VTOL_TRANSITION_HEADING_SPECIFIED = 3
    VTOL_TRANSITION_HEADING_ANY = 4

class CAMERA_CAP_FLAGS(IntEnum):
    CAMERA_CAP_FLAGS_CAPTURE_VIDEO = 1
    CAMERA_CAP_FLAGS_CAPTURE_IMAGE = 2
    CAMERA_CAP_FLAGS_HAS_MODES = 4
    CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE = 8
    CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE = 16
    CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE = 32
    CAMERA_CAP_FLAGS_HAS_BASIC_ZOOM = 64
    CAMERA_CAP_FLAGS_HAS_BASIC_FOCUS = 128
    CAMERA_CAP_FLAGS_HAS_VIDEO_STREAM = 256
    CAMERA_CAP_FLAGS_HAS_TRACKING_POINT = 512
    CAMERA_CAP_FLAGS_HAS_TRACKING_RECTANGLE = 1024
    CAMERA_CAP_FLAGS_HAS_TRACKING_GEO_STATUS = 2048
    CAMERA_CAP_FLAGS_HAS_THERMAL_RANGE = 4096

class VIDEO_STREAM_STATUS_FLAGS(IntEnum):
    VIDEO_STREAM_STATUS_FLAGS_RUNNING = 1
    VIDEO_STREAM_STATUS_FLAGS_THERMAL = 2
    VIDEO_STREAM_STATUS_FLAGS_THERMAL_RANGE_ENABLED = 4

class VIDEO_STREAM_TYPE(IntEnum):
    VIDEO_STREAM_TYPE_RTSP = 0
    VIDEO_STREAM_TYPE_RTPUDP = 1
    VIDEO_STREAM_TYPE_TCP_MPEG = 2
    VIDEO_STREAM_TYPE_MPEG_TS = 3

class VIDEO_STREAM_ENCODING(IntEnum):
    VIDEO_STREAM_ENCODING_UNKNOWN = 0
    VIDEO_STREAM_ENCODING_H264 = 1
    VIDEO_STREAM_ENCODING_H265 = 2

class CAMERA_TRACKING_STATUS_FLAGS(IntEnum):
    CAMERA_TRACKING_STATUS_FLAGS_IDLE = 0
    CAMERA_TRACKING_STATUS_FLAGS_ACTIVE = 1
    CAMERA_TRACKING_STATUS_FLAGS_ERROR = 2

class CAMERA_TRACKING_MODE(IntEnum):
    CAMERA_TRACKING_MODE_NONE = 0
    CAMERA_TRACKING_MODE_POINT = 1
    CAMERA_TRACKING_MODE_RECTANGLE = 2

class CAMERA_TRACKING_TARGET_DATA(IntEnum):
    CAMERA_TRACKING_TARGET_DATA_NONE = 0
    CAMERA_TRACKING_TARGET_DATA_EMBEDDED = 1
    CAMERA_TRACKING_TARGET_DATA_RENDERED = 2
    CAMERA_TRACKING_TARGET_DATA_IN_STATUS = 4

class CAMERA_ZOOM_TYPE(IntEnum):
    ZOOM_TYPE_STEP = 0
    ZOOM_TYPE_CONTINUOUS = 1
    ZOOM_TYPE_RANGE = 2
    ZOOM_TYPE_FOCAL_LENGTH = 3
    ZOOM_TYPE_HORIZONTAL_FOV = 4

class SET_FOCUS_TYPE(IntEnum):
    FOCUS_TYPE_STEP = 0
    FOCUS_TYPE_CONTINUOUS = 1
    FOCUS_TYPE_RANGE = 2
    FOCUS_TYPE_METERS = 3
    FOCUS_TYPE_AUTO = 4
    FOCUS_TYPE_AUTO_SINGLE = 5
    FOCUS_TYPE_AUTO_CONTINUOUS = 6

class CAMERA_SOURCE(IntEnum):
    CAMERA_SOURCE_DEFAULT = 0
    CAMERA_SOURCE_RGB = 1
    CAMERA_SOURCE_IR = 2
    CAMERA_SOURCE_NDVI = 3

class PARAM_ACK(IntEnum):
    PARAM_ACK_ACCEPTED = 0
    PARAM_ACK_VALUE_UNSUPPORTED = 1
    PARAM_ACK_FAILED = 2
    PARAM_ACK_IN_PROGRESS = 3

class CAMERA_MODE(IntEnum):
    CAMERA_MODE_IMAGE = 0
    CAMERA_MODE_VIDEO = 1
    CAMERA_MODE_IMAGE_SURVEY = 2

class MAV_ARM_AUTH_DENIED_REASON(IntEnum):
    MAV_ARM_AUTH_DENIED_REASON_GENERIC = 0
    MAV_ARM_AUTH_DENIED_REASON_NONE = 1
    MAV_ARM_AUTH_DENIED_REASON_INVALID_WAYPOINT = 2
    MAV_ARM_AUTH_DENIED_REASON_TIMEOUT = 3
    MAV_ARM_AUTH_DENIED_REASON_AIRSPACE_IN_USE = 4
    MAV_ARM_AUTH_DENIED_REASON_BAD_WEATHER = 5

class RC_TYPE(IntEnum):
    RC_TYPE_SPEKTRUM = 0
    RC_TYPE_CRSF = 1

class RC_SUB_TYPE(IntEnum):
    RC_SUB_TYPE_SPEKTRUM_DSM2 = 0
    RC_SUB_TYPE_SPEKTRUM_DSMX = 1
    RC_SUB_TYPE_SPEKTRUM_DSMX8 = 2

class POSITION_TARGET_TYPEMASK(IntEnum):
    POSITION_TARGET_TYPEMASK_X_IGNORE = 1
    POSITION_TARGET_TYPEMASK_Y_IGNORE = 2
    POSITION_TARGET_TYPEMASK_Z_IGNORE = 4
    POSITION_TARGET_TYPEMASK_VX_IGNORE = 8
    POSITION_TARGET_TYPEMASK_VY_IGNORE = 16
    POSITION_TARGET_TYPEMASK_VZ_IGNORE = 32
    POSITION_TARGET_TYPEMASK_AX_IGNORE = 64
    POSITION_TARGET_TYPEMASK_AY_IGNORE = 128
    POSITION_TARGET_TYPEMASK_AZ_IGNORE = 256
    POSITION_TARGET_TYPEMASK_FORCE_SET = 512
    POSITION_TARGET_TYPEMASK_YAW_IGNORE = 1024
    POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE = 2048

class ATTITUDE_TARGET_TYPEMASK(IntEnum):
    ATTITUDE_TARGET_TYPEMASK_BODY_ROLL_RATE_IGNORE = 1
    ATTITUDE_TARGET_TYPEMASK_BODY_PITCH_RATE_IGNORE = 2
    ATTITUDE_TARGET_TYPEMASK_BODY_YAW_RATE_IGNORE = 4
    ATTITUDE_TARGET_TYPEMASK_THRUST_BODY_SET = 32
    ATTITUDE_TARGET_TYPEMASK_THROTTLE_IGNORE = 64
    ATTITUDE_TARGET_TYPEMASK_ATTITUDE_IGNORE = 128

class UTM_FLIGHT_STATE(IntEnum):
    UTM_FLIGHT_STATE_UNKNOWN = 1
    UTM_FLIGHT_STATE_GROUND = 2
    UTM_FLIGHT_STATE_AIRBORNE = 3
    UTM_FLIGHT_STATE_EMERGENCY = 16
    UTM_FLIGHT_STATE_NOCTRL = 32

class UTM_DATA_AVAIL_FLAGS(IntEnum):
    UTM_DATA_AVAIL_FLAGS_TIME_VALID = 1
    UTM_DATA_AVAIL_FLAGS_UAS_ID_AVAILABLE = 2
    UTM_DATA_AVAIL_FLAGS_POSITION_AVAILABLE = 4
    UTM_DATA_AVAIL_FLAGS_ALTITUDE_AVAILABLE = 8
    UTM_DATA_AVAIL_FLAGS_RELATIVE_ALTITUDE_AVAILABLE = 16
    UTM_DATA_AVAIL_FLAGS_HORIZONTAL_VELO_AVAILABLE = 32
    UTM_DATA_AVAIL_FLAGS_VERTICAL_VELO_AVAILABLE = 64
    UTM_DATA_AVAIL_FLAGS_NEXT_WAYPOINT_AVAILABLE = 128

class CELLULAR_STATUS_FLAG(IntEnum):
    CELLULAR_STATUS_FLAG_UNKNOWN = 0
    CELLULAR_STATUS_FLAG_FAILED = 1
    CELLULAR_STATUS_FLAG_INITIALIZING = 2
    CELLULAR_STATUS_FLAG_LOCKED = 3
    CELLULAR_STATUS_FLAG_DISABLED = 4
    CELLULAR_STATUS_FLAG_DISABLING = 5
    CELLULAR_STATUS_FLAG_ENABLING = 6
    CELLULAR_STATUS_FLAG_ENABLED = 7
    CELLULAR_STATUS_FLAG_SEARCHING = 8
    CELLULAR_STATUS_FLAG_REGISTERED = 9
    CELLULAR_STATUS_FLAG_DISCONNECTING = 10
    CELLULAR_STATUS_FLAG_CONNECTING = 11
    CELLULAR_STATUS_FLAG_CONNECTED = 12

class CELLULAR_NETWORK_FAILED_REASON(IntEnum):
    CELLULAR_NETWORK_FAILED_REASON_NONE = 0
    CELLULAR_NETWORK_FAILED_REASON_UNKNOWN = 1
    CELLULAR_NETWORK_FAILED_REASON_SIM_MISSING = 2
    CELLULAR_NETWORK_FAILED_REASON_SIM_ERROR = 3

class CELLULAR_NETWORK_RADIO_TYPE(IntEnum):
    CELLULAR_NETWORK_RADIO_TYPE_NONE = 0
    CELLULAR_NETWORK_RADIO_TYPE_GSM = 1
    CELLULAR_NETWORK_RADIO_TYPE_CDMA = 2
    CELLULAR_NETWORK_RADIO_TYPE_WCDMA = 3
    CELLULAR_NETWORK_RADIO_TYPE_LTE = 4

class PRECISION_LAND_MODE(IntEnum):
    PRECISION_LAND_MODE_DISABLED = 0
    PRECISION_LAND_MODE_OPPORTUNISTIC = 1
    PRECISION_LAND_MODE_REQUIRED = 2

class PARACHUTE_ACTION(IntEnum):
    PARACHUTE_DISABLE = 0
    PARACHUTE_ENABLE = 1
    PARACHUTE_RELEASE = 2

class MAV_TUNNEL_PAYLOAD_TYPE(IntEnum):
    MAV_TUNNEL_PAYLOAD_TYPE_UNKNOWN = 0
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED0 = 200
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED1 = 201
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED2 = 202
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED3 = 203
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED4 = 204
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED5 = 205
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED6 = 206
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED7 = 207
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED8 = 208
    MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED9 = 209

class MAV_ODID_ID_TYPE(IntEnum):
    MAV_ODID_ID_TYPE_NONE = 0
    MAV_ODID_ID_TYPE_SERIAL_NUMBER = 1
    MAV_ODID_ID_TYPE_CAA_REGISTRATION_ID = 2
    MAV_ODID_ID_TYPE_UTM_ASSIGNED_UUID = 3
    MAV_ODID_ID_TYPE_SPECIFIC_SESSION_ID = 4

class MAV_ODID_UA_TYPE(IntEnum):
    MAV_ODID_UA_TYPE_NONE = 0
    MAV_ODID_UA_TYPE_AEROPLANE = 1
    MAV_ODID_UA_TYPE_HELICOPTER_OR_MULTIROTOR = 2
    MAV_ODID_UA_TYPE_GYROPLANE = 3
    MAV_ODID_UA_TYPE_HYBRID_LIFT = 4
    MAV_ODID_UA_TYPE_ORNITHOPTER = 5
    MAV_ODID_UA_TYPE_GLIDER = 6
    MAV_ODID_UA_TYPE_KITE = 7
    MAV_ODID_UA_TYPE_FREE_BALLOON = 8
    MAV_ODID_UA_TYPE_CAPTIVE_BALLOON = 9
    MAV_ODID_UA_TYPE_AIRSHIP = 10
    MAV_ODID_UA_TYPE_FREE_FALL_PARACHUTE = 11
    MAV_ODID_UA_TYPE_ROCKET = 12
    MAV_ODID_UA_TYPE_TETHERED_POWERED_AIRCRAFT = 13
    MAV_ODID_UA_TYPE_GROUND_OBSTACLE = 14
    MAV_ODID_UA_TYPE_OTHER = 15

class MAV_ODID_STATUS(IntEnum):
    MAV_ODID_STATUS_UNDECLARED = 0
    MAV_ODID_STATUS_GROUND = 1
    MAV_ODID_STATUS_AIRBORNE = 2
    MAV_ODID_STATUS_EMERGENCY = 3
    MAV_ODID_STATUS_REMOTE_ID_SYSTEM_FAILURE = 4

class MAV_ODID_HEIGHT_REF(IntEnum):
    MAV_ODID_HEIGHT_REF_OVER_TAKEOFF = 0
    MAV_ODID_HEIGHT_REF_OVER_GROUND = 1

class MAV_ODID_HOR_ACC(IntEnum):
    MAV_ODID_HOR_ACC_UNKNOWN = 0
    MAV_ODID_HOR_ACC_10NM = 1
    MAV_ODID_HOR_ACC_4NM = 2
    MAV_ODID_HOR_ACC_2NM = 3
    MAV_ODID_HOR_ACC_1NM = 4
    MAV_ODID_HOR_ACC_0_5NM = 5
    MAV_ODID_HOR_ACC_0_3NM = 6
    MAV_ODID_HOR_ACC_0_1NM = 7
    MAV_ODID_HOR_ACC_0_05NM = 8
    MAV_ODID_HOR_ACC_30_METER = 9
    MAV_ODID_HOR_ACC_10_METER = 10
    MAV_ODID_HOR_ACC_3_METER = 11
    MAV_ODID_HOR_ACC_1_METER = 12

class MAV_ODID_VER_ACC(IntEnum):
    MAV_ODID_VER_ACC_UNKNOWN = 0
    MAV_ODID_VER_ACC_150_METER = 1
    MAV_ODID_VER_ACC_45_METER = 2
    MAV_ODID_VER_ACC_25_METER = 3
    MAV_ODID_VER_ACC_10_METER = 4
    MAV_ODID_VER_ACC_3_METER = 5
    MAV_ODID_VER_ACC_1_METER = 6

class MAV_ODID_SPEED_ACC(IntEnum):
    MAV_ODID_SPEED_ACC_UNKNOWN = 0
    MAV_ODID_SPEED_ACC_10_METERS_PER_SECOND = 1
    MAV_ODID_SPEED_ACC_3_METERS_PER_SECOND = 2
    MAV_ODID_SPEED_ACC_1_METERS_PER_SECOND = 3
    MAV_ODID_SPEED_ACC_0_3_METERS_PER_SECOND = 4

class MAV_ODID_TIME_ACC(IntEnum):
    MAV_ODID_TIME_ACC_UNKNOWN = 0
    MAV_ODID_TIME_ACC_0_1_SECOND = 1
    MAV_ODID_TIME_ACC_0_2_SECOND = 2
    MAV_ODID_TIME_ACC_0_3_SECOND = 3
    MAV_ODID_TIME_ACC_0_4_SECOND = 4
    MAV_ODID_TIME_ACC_0_5_SECOND = 5
    MAV_ODID_TIME_ACC_0_6_SECOND = 6
    MAV_ODID_TIME_ACC_0_7_SECOND = 7
    MAV_ODID_TIME_ACC_0_8_SECOND = 8
    MAV_ODID_TIME_ACC_0_9_SECOND = 9
    MAV_ODID_TIME_ACC_1_0_SECOND = 10
    MAV_ODID_TIME_ACC_1_1_SECOND = 11
    MAV_ODID_TIME_ACC_1_2_SECOND = 12
    MAV_ODID_TIME_ACC_1_3_SECOND = 13
    MAV_ODID_TIME_ACC_1_4_SECOND = 14
    MAV_ODID_TIME_ACC_1_5_SECOND = 15

class MAV_ODID_AUTH_TYPE(IntEnum):
    MAV_ODID_AUTH_TYPE_NONE = 0
    MAV_ODID_AUTH_TYPE_UAS_ID_SIGNATURE = 1
    MAV_ODID_AUTH_TYPE_OPERATOR_ID_SIGNATURE = 2
    MAV_ODID_AUTH_TYPE_MESSAGE_SET_SIGNATURE = 3
    MAV_ODID_AUTH_TYPE_NETWORK_REMOTE_ID = 4
    MAV_ODID_AUTH_TYPE_SPECIFIC_AUTHENTICATION = 5

class MAV_ODID_DESC_TYPE(IntEnum):
    MAV_ODID_DESC_TYPE_TEXT = 0
    MAV_ODID_DESC_TYPE_EMERGENCY = 1
    MAV_ODID_DESC_TYPE_EXTENDED_STATUS = 2

class MAV_ODID_OPERATOR_LOCATION_TYPE(IntEnum):
    MAV_ODID_OPERATOR_LOCATION_TYPE_TAKEOFF = 0
    MAV_ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS = 1
    MAV_ODID_OPERATOR_LOCATION_TYPE_FIXED = 2

class MAV_ODID_CLASSIFICATION_TYPE(IntEnum):
    MAV_ODID_CLASSIFICATION_TYPE_UNDECLARED = 0
    MAV_ODID_CLASSIFICATION_TYPE_EU = 1

class MAV_ODID_CATEGORY_EU(IntEnum):
    MAV_ODID_CATEGORY_EU_UNDECLARED = 0
    MAV_ODID_CATEGORY_EU_OPEN = 1
    MAV_ODID_CATEGORY_EU_SPECIFIC = 2
    MAV_ODID_CATEGORY_EU_CERTIFIED = 3

class MAV_ODID_CLASS_EU(IntEnum):
    MAV_ODID_CLASS_EU_UNDECLARED = 0
    MAV_ODID_CLASS_EU_CLASS_0 = 1
    MAV_ODID_CLASS_EU_CLASS_1 = 2
    MAV_ODID_CLASS_EU_CLASS_2 = 3
    MAV_ODID_CLASS_EU_CLASS_3 = 4
    MAV_ODID_CLASS_EU_CLASS_4 = 5
    MAV_ODID_CLASS_EU_CLASS_5 = 6
    MAV_ODID_CLASS_EU_CLASS_6 = 7

class MAV_ODID_OPERATOR_ID_TYPE(IntEnum):
    MAV_ODID_OPERATOR_ID_TYPE_CAA = 0

class MAV_ODID_ARM_STATUS(IntEnum):
    MAV_ODID_ARM_STATUS_GOOD_TO_ARM = 0
    MAV_ODID_ARM_STATUS_PRE_ARM_FAIL_GENERIC = 1

class TUNE_FORMAT(IntEnum):
    TUNE_FORMAT_QBASIC1_1 = 1
    TUNE_FORMAT_MML_MODERN = 2

class AIS_TYPE(IntEnum):
    AIS_TYPE_UNKNOWN = 0
    AIS_TYPE_RESERVED_1 = 1
    AIS_TYPE_RESERVED_2 = 2
    AIS_TYPE_RESERVED_3 = 3
    AIS_TYPE_RESERVED_4 = 4
    AIS_TYPE_RESERVED_5 = 5
    AIS_TYPE_RESERVED_6 = 6
    AIS_TYPE_RESERVED_7 = 7
    AIS_TYPE_RESERVED_8 = 8
    AIS_TYPE_RESERVED_9 = 9
    AIS_TYPE_RESERVED_10 = 10
    AIS_TYPE_RESERVED_11 = 11
    AIS_TYPE_RESERVED_12 = 12
    AIS_TYPE_RESERVED_13 = 13
    AIS_TYPE_RESERVED_14 = 14
    AIS_TYPE_RESERVED_15 = 15
    AIS_TYPE_RESERVED_16 = 16
    AIS_TYPE_RESERVED_17 = 17
    AIS_TYPE_RESERVED_18 = 18
    AIS_TYPE_RESERVED_19 = 19
    AIS_TYPE_WIG = 20
    AIS_TYPE_WIG_HAZARDOUS_A = 21
    AIS_TYPE_WIG_HAZARDOUS_B = 22
    AIS_TYPE_WIG_HAZARDOUS_C = 23
    AIS_TYPE_WIG_HAZARDOUS_D = 24
    AIS_TYPE_WIG_RESERVED_1 = 25
    AIS_TYPE_WIG_RESERVED_2 = 26
    AIS_TYPE_WIG_RESERVED_3 = 27
    AIS_TYPE_WIG_RESERVED_4 = 28
    AIS_TYPE_WIG_RESERVED_5 = 29
    AIS_TYPE_FISHING = 30
    AIS_TYPE_TOWING = 31
    AIS_TYPE_TOWING_LARGE = 32
    AIS_TYPE_DREDGING = 33
    AIS_TYPE_DIVING = 34
    AIS_TYPE_MILITARY = 35
    AIS_TYPE_SAILING = 36
    AIS_TYPE_PLEASURE = 37
    AIS_TYPE_RESERVED_20 = 38
    AIS_TYPE_RESERVED_21 = 39
    AIS_TYPE_HSC = 40
    AIS_TYPE_HSC_HAZARDOUS_A = 41
    AIS_TYPE_HSC_HAZARDOUS_B = 42
    AIS_TYPE_HSC_HAZARDOUS_C = 43
    AIS_TYPE_HSC_HAZARDOUS_D = 44
    AIS_TYPE_HSC_RESERVED_1 = 45
    AIS_TYPE_HSC_RESERVED_2 = 46
    AIS_TYPE_HSC_RESERVED_3 = 47
    AIS_TYPE_HSC_RESERVED_4 = 48
    AIS_TYPE_HSC_UNKNOWN = 49
    AIS_TYPE_PILOT = 50
    AIS_TYPE_SAR = 51
    AIS_TYPE_TUG = 52
    AIS_TYPE_PORT_TENDER = 53
    AIS_TYPE_ANTI_POLLUTION = 54
    AIS_TYPE_LAW_ENFORCEMENT = 55
    AIS_TYPE_SPARE_LOCAL_1 = 56
    AIS_TYPE_SPARE_LOCAL_2 = 57
    AIS_TYPE_MEDICAL_TRANSPORT = 58
    AIS_TYPE_NONECOMBATANT = 59
    AIS_TYPE_PASSENGER = 60
    AIS_TYPE_PASSENGER_HAZARDOUS_A = 61
    AIS_TYPE_PASSENGER_HAZARDOUS_B = 62
    AIS_TYPE_PASSENGER_HAZARDOUS_C = 63
    AIS_TYPE_PASSENGER_HAZARDOUS_D = 64
    AIS_TYPE_PASSENGER_RESERVED_1 = 65
    AIS_TYPE_PASSENGER_RESERVED_2 = 66
    AIS_TYPE_PASSENGER_RESERVED_3 = 67
    AIS_TYPE_PASSENGER_RESERVED_4 = 68
    AIS_TYPE_PASSENGER_UNKNOWN = 69
    AIS_TYPE_CARGO = 70
    AIS_TYPE_CARGO_HAZARDOUS_A = 71
    AIS_TYPE_CARGO_HAZARDOUS_B = 72
    AIS_TYPE_CARGO_HAZARDOUS_C = 73
    AIS_TYPE_CARGO_HAZARDOUS_D = 74
    AIS_TYPE_CARGO_RESERVED_1 = 75
    AIS_TYPE_CARGO_RESERVED_2 = 76
    AIS_TYPE_CARGO_RESERVED_3 = 77
    AIS_TYPE_CARGO_RESERVED_4 = 78
    AIS_TYPE_CARGO_UNKNOWN = 79
    AIS_TYPE_TANKER = 80
    AIS_TYPE_TANKER_HAZARDOUS_A = 81
    AIS_TYPE_TANKER_HAZARDOUS_B = 82
    AIS_TYPE_TANKER_HAZARDOUS_C = 83
    AIS_TYPE_TANKER_HAZARDOUS_D = 84
    AIS_TYPE_TANKER_RESERVED_1 = 85
    AIS_TYPE_TANKER_RESERVED_2 = 86
    AIS_TYPE_TANKER_RESERVED_3 = 87
    AIS_TYPE_TANKER_RESERVED_4 = 88
    AIS_TYPE_TANKER_UNKNOWN = 89
    AIS_TYPE_OTHER = 90
    AIS_TYPE_OTHER_HAZARDOUS_A = 91
    AIS_TYPE_OTHER_HAZARDOUS_B = 92
    AIS_TYPE_OTHER_HAZARDOUS_C = 93
    AIS_TYPE_OTHER_HAZARDOUS_D = 94
    AIS_TYPE_OTHER_RESERVED_1 = 95
    AIS_TYPE_OTHER_RESERVED_2 = 96
    AIS_TYPE_OTHER_RESERVED_3 = 97
    AIS_TYPE_OTHER_RESERVED_4 = 98
    AIS_TYPE_OTHER_UNKNOWN = 99

class AIS_NAV_STATUS(IntEnum):
    UNDER_WAY = 0
    AIS_NAV_ANCHORED = 1
    AIS_NAV_UN_COMMANDED = 2
    AIS_NAV_RESTRICTED_MANOEUVERABILITY = 3
    AIS_NAV_DRAUGHT_CONSTRAINED = 4
    AIS_NAV_MOORED = 5
    AIS_NAV_AGROUND = 6
    AIS_NAV_FISHING = 7
    AIS_NAV_SAILING = 8
    AIS_NAV_RESERVED_HSC = 9
    AIS_NAV_RESERVED_WIG = 10
    AIS_NAV_RESERVED_1 = 11
    AIS_NAV_RESERVED_2 = 12
    AIS_NAV_RESERVED_3 = 13
    AIS_NAV_AIS_SART = 14
    AIS_NAV_UNKNOWN = 15

class AIS_FLAGS(IntEnum):
    AIS_FLAGS_POSITION_ACCURACY = 1
    AIS_FLAGS_VALID_COG = 2
    AIS_FLAGS_VALID_VELOCITY = 4
    AIS_FLAGS_HIGH_VELOCITY = 8
    AIS_FLAGS_VALID_TURN_RATE = 16
    AIS_FLAGS_TURN_RATE_SIGN_ONLY = 32
    AIS_FLAGS_VALID_DIMENSIONS = 64
    AIS_FLAGS_LARGE_BOW_DIMENSION = 128
    AIS_FLAGS_LARGE_STERN_DIMENSION = 256
    AIS_FLAGS_LARGE_PORT_DIMENSION = 512
    AIS_FLAGS_LARGE_STARBOARD_DIMENSION = 1024
    AIS_FLAGS_VALID_CALLSIGN = 2048
    AIS_FLAGS_VALID_NAME = 4096

class FAILURE_UNIT(IntEnum):
    FAILURE_UNIT_SENSOR_GYRO = 0
    FAILURE_UNIT_SENSOR_ACCEL = 1
    FAILURE_UNIT_SENSOR_MAG = 2
    FAILURE_UNIT_SENSOR_BARO = 3
    FAILURE_UNIT_SENSOR_GPS = 4
    FAILURE_UNIT_SENSOR_OPTICAL_FLOW = 5
    FAILURE_UNIT_SENSOR_VIO = 6
    FAILURE_UNIT_SENSOR_DISTANCE_SENSOR = 7
    FAILURE_UNIT_SENSOR_AIRSPEED = 8
    FAILURE_UNIT_SYSTEM_BATTERY = 100
    FAILURE_UNIT_SYSTEM_MOTOR = 101
    FAILURE_UNIT_SYSTEM_SERVO = 102
    FAILURE_UNIT_SYSTEM_AVOIDANCE = 103
    FAILURE_UNIT_SYSTEM_RC_SIGNAL = 104
    FAILURE_UNIT_SYSTEM_MAVLINK_SIGNAL = 105

class FAILURE_TYPE(IntEnum):
    FAILURE_TYPE_OK = 0
    FAILURE_TYPE_OFF = 1
    FAILURE_TYPE_STUCK = 2
    FAILURE_TYPE_GARBAGE = 3
    FAILURE_TYPE_WRONG = 4
    FAILURE_TYPE_SLOW = 5
    FAILURE_TYPE_DELAYED = 6
    FAILURE_TYPE_INTERMITTENT = 7

class NAV_VTOL_LAND_OPTIONS(IntEnum):
    NAV_VTOL_LAND_OPTIONS_DEFAULT = 0
    NAV_VTOL_LAND_OPTIONS_FW_DESCENT = 1
    NAV_VTOL_LAND_OPTIONS_HOVER_DESCENT = 2

class MAV_WINCH_STATUS_FLAG(IntEnum):
    MAV_WINCH_STATUS_HEALTHY = 1
    MAV_WINCH_STATUS_FULLY_RETRACTED = 2
    MAV_WINCH_STATUS_MOVING = 4
    MAV_WINCH_STATUS_CLUTCH_ENGAGED = 8
    MAV_WINCH_STATUS_LOCKED = 16
    MAV_WINCH_STATUS_DROPPING = 32
    MAV_WINCH_STATUS_ARRESTING = 64
    MAV_WINCH_STATUS_GROUND_SENSE = 128
    MAV_WINCH_STATUS_RETRACTING = 256
    MAV_WINCH_STATUS_REDELIVER = 512
    MAV_WINCH_STATUS_ABANDON_LINE = 1024
    MAV_WINCH_STATUS_LOCKING = 2048
    MAV_WINCH_STATUS_LOAD_LINE = 4096
    MAV_WINCH_STATUS_LOAD_PAYLOAD = 8192

class MAG_CAL_STATUS(IntEnum):
    MAG_CAL_NOT_STARTED = 0
    MAG_CAL_WAITING_TO_START = 1
    MAG_CAL_RUNNING_STEP_ONE = 2
    MAG_CAL_RUNNING_STEP_TWO = 3
    MAG_CAL_SUCCESS = 4
    MAG_CAL_FAILED = 5
    MAG_CAL_BAD_ORIENTATION = 6
    MAG_CAL_BAD_RADIUS = 7

class MAV_EVENT_ERROR_REASON(IntEnum):
    MAV_EVENT_ERROR_REASON_UNAVAILABLE = 0

class MAV_EVENT_CURRENT_SEQUENCE_FLAGS(IntEnum):
    MAV_EVENT_CURRENT_SEQUENCE_FLAGS_RESET = 1

class HIL_SENSOR_UPDATED_FLAGS(IntEnum):
    HIL_SENSOR_UPDATED_NONE = 0
    HIL_SENSOR_UPDATED_XACC = 1
    HIL_SENSOR_UPDATED_YACC = 2
    HIL_SENSOR_UPDATED_ZACC = 4
    HIL_SENSOR_UPDATED_XGYRO = 8
    HIL_SENSOR_UPDATED_YGYRO = 16
    HIL_SENSOR_UPDATED_ZGYRO = 32
    HIL_SENSOR_UPDATED_XMAG = 64
    HIL_SENSOR_UPDATED_YMAG = 128
    HIL_SENSOR_UPDATED_ZMAG = 256
    HIL_SENSOR_UPDATED_ABS_PRESSURE = 512
    HIL_SENSOR_UPDATED_DIFF_PRESSURE = 1024
    HIL_SENSOR_UPDATED_PRESSURE_ALT = 2048
    HIL_SENSOR_UPDATED_TEMPERATURE = 4096
    HIL_SENSOR_UPDATED_RESET = 2147483648

class HIGHRES_IMU_UPDATED_FLAGS(IntEnum):
    HIGHRES_IMU_UPDATED_NONE = 0
    HIGHRES_IMU_UPDATED_XACC = 1
    HIGHRES_IMU_UPDATED_YACC = 2
    HIGHRES_IMU_UPDATED_ZACC = 4
    HIGHRES_IMU_UPDATED_XGYRO = 8
    HIGHRES_IMU_UPDATED_YGYRO = 16
    HIGHRES_IMU_UPDATED_ZGYRO = 32
    HIGHRES_IMU_UPDATED_XMAG = 64
    HIGHRES_IMU_UPDATED_YMAG = 128
    HIGHRES_IMU_UPDATED_ZMAG = 256
    HIGHRES_IMU_UPDATED_ABS_PRESSURE = 512
    HIGHRES_IMU_UPDATED_DIFF_PRESSURE = 1024
    HIGHRES_IMU_UPDATED_PRESSURE_ALT = 2048
    HIGHRES_IMU_UPDATED_TEMPERATURE = 4096
    HIGHRES_IMU_UPDATED_ALL = 65535

class CAN_FILTER_OP(IntEnum):
    CAN_FILTER_REPLACE = 0
    CAN_FILTER_ADD = 1
    CAN_FILTER_REMOVE = 2

class MAV_FTP_ERR(IntEnum):
    MAV_FTP_ERR_NONE = 0
    MAV_FTP_ERR_FAIL = 1
    MAV_FTP_ERR_FAILERRNO = 2
    MAV_FTP_ERR_INVALIDDATASIZE = 3
    MAV_FTP_ERR_INVALIDSESSION = 4
    MAV_FTP_ERR_NOSESSIONSAVAILABLE = 5
    MAV_FTP_ERR_EOF = 6
    MAV_FTP_ERR_UNKNOWNCOMMAND = 7
    MAV_FTP_ERR_FILEEXISTS = 8
    MAV_FTP_ERR_FILEPROTECTED = 9
    MAV_FTP_ERR_FILENOTFOUND = 10

class MAV_FTP_OPCODE(IntEnum):
    MAV_FTP_OPCODE_NONE = 0
    MAV_FTP_OPCODE_TERMINATESESSION = 1
    MAV_FTP_OPCODE_RESETSESSION = 2
    MAV_FTP_OPCODE_LISTDIRECTORY = 3
    MAV_FTP_OPCODE_OPENFILERO = 4
    MAV_FTP_OPCODE_READFILE = 5
    MAV_FTP_OPCODE_CREATEFILE = 6
    MAV_FTP_OPCODE_WRITEFILE = 7
    MAV_FTP_OPCODE_REMOVEFILE = 8
    MAV_FTP_OPCODE_CREATEDIRECTORY = 9
    MAV_FTP_OPCODE_REMOVEDIRECTORY = 10
    MAV_FTP_OPCODE_OPENFILEWO = 11
    MAV_FTP_OPCODE_TRUNCATEFILE = 12
    MAV_FTP_OPCODE_RENAME = 13
    MAV_FTP_OPCODE_CALCFILECRC = 14
    MAV_FTP_OPCODE_BURSTREADFILE = 15
    MAV_FTP_OPCODE_ACK = 128
    MAV_FTP_OPCODE_NAK = 129

class MISSION_STATE(IntEnum):
    MISSION_STATE_UNKNOWN = 0
    MISSION_STATE_NO_MISSION = 1
    MISSION_STATE_NOT_STARTED = 2
    MISSION_STATE_ACTIVE = 3
    MISSION_STATE_PAUSED = 4
    MISSION_STATE_COMPLETE = 5

class SAFETY_SWITCH_STATE(IntEnum):
    SAFETY_SWITCH_STATE_SAFE = 0
    SAFETY_SWITCH_STATE_DANGEROUS = 1

class ILLUMINATOR_MODE(IntEnum):
    ILLUMINATOR_MODE_UNKNOWN = 0
    ILLUMINATOR_MODE_INTERNAL_CONTROL = 1
    ILLUMINATOR_MODE_EXTERNAL_SYNC = 2

class ILLUMINATOR_ERROR_FLAGS(IntEnum):
    ILLUMINATOR_ERROR_FLAGS_THERMAL_THROTTLING = 1
    ILLUMINATOR_ERROR_FLAGS_OVER_TEMPERATURE_SHUTDOWN = 2
    ILLUMINATOR_ERROR_FLAGS_THERMISTOR_FAILURE = 4

class MAV_AUTOPILOT(IntEnum):
    MAV_AUTOPILOT_GENERIC = 0
    MAV_AUTOPILOT_RESERVED = 1
    MAV_AUTOPILOT_SLUGS = 2
    MAV_AUTOPILOT_ARDUPILOTMEGA = 3
    MAV_AUTOPILOT_OPENPILOT = 4
    MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY = 5
    MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = 6
    MAV_AUTOPILOT_GENERIC_MISSION_FULL = 7
    MAV_AUTOPILOT_INVALID = 8
    MAV_AUTOPILOT_PPZ = 9
    MAV_AUTOPILOT_UDB = 10
    MAV_AUTOPILOT_FP = 11
    MAV_AUTOPILOT_PX4 = 12
    MAV_AUTOPILOT_SMACCMPILOT = 13
    MAV_AUTOPILOT_AUTOQUAD = 14
    MAV_AUTOPILOT_ARMAZILA = 15
    MAV_AUTOPILOT_AEROB = 16
    MAV_AUTOPILOT_ASLUAV = 17
    MAV_AUTOPILOT_SMARTAP = 18
    MAV_AUTOPILOT_AIRRAILS = 19
    MAV_AUTOPILOT_REFLEX = 20

class MAV_TYPE(IntEnum):
    MAV_TYPE_GENERIC = 0
    MAV_TYPE_FIXED_WING = 1
    MAV_TYPE_QUADROTOR = 2
    MAV_TYPE_COAXIAL = 3
    MAV_TYPE_HELICOPTER = 4
    MAV_TYPE_ANTENNA_TRACKER = 5
    MAV_TYPE_GCS = 6
    MAV_TYPE_AIRSHIP = 7
    MAV_TYPE_FREE_BALLOON = 8
    MAV_TYPE_ROCKET = 9
    MAV_TYPE_GROUND_ROVER = 10
    MAV_TYPE_SURFACE_BOAT = 11
    MAV_TYPE_SUBMARINE = 12
    MAV_TYPE_HEXAROTOR = 13
    MAV_TYPE_OCTOROTOR = 14
    MAV_TYPE_TRICOPTER = 15
    MAV_TYPE_FLAPPING_WING = 16
    MAV_TYPE_KITE = 17
    MAV_TYPE_ONBOARD_CONTROLLER = 18
    MAV_TYPE_VTOL_TAILSITTER_DUOROTOR = 19
    MAV_TYPE_VTOL_TAILSITTER_QUADROTOR = 20
    MAV_TYPE_VTOL_TILTROTOR = 21
    MAV_TYPE_VTOL_FIXEDROTOR = 22
    MAV_TYPE_VTOL_TAILSITTER = 23
    MAV_TYPE_VTOL_TILTWING = 24
    MAV_TYPE_VTOL_RESERVED5 = 25
    MAV_TYPE_GIMBAL = 26
    MAV_TYPE_ADSB = 27
    MAV_TYPE_PARAFOIL = 28
    MAV_TYPE_DODECAROTOR = 29
    MAV_TYPE_CAMERA = 30
    MAV_TYPE_CHARGING_STATION = 31
    MAV_TYPE_FLARM = 32
    MAV_TYPE_SERVO = 33
    MAV_TYPE_ODID = 34
    MAV_TYPE_DECAROTOR = 35
    MAV_TYPE_BATTERY = 36
    MAV_TYPE_PARACHUTE = 37
    MAV_TYPE_LOG = 38
    MAV_TYPE_OSD = 39
    MAV_TYPE_IMU = 40
    MAV_TYPE_GPS = 41
    MAV_TYPE_WINCH = 42
    MAV_TYPE_GENERIC_MULTIROTOR = 43
    MAV_TYPE_ILLUMINATOR = 44

class MAV_MODE_FLAG(IntEnum):
    MAV_MODE_FLAG_SAFETY_ARMED = 128
    MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = 64
    MAV_MODE_FLAG_HIL_ENABLED = 32
    MAV_MODE_FLAG_STABILIZE_ENABLED = 16
    MAV_MODE_FLAG_GUIDED_ENABLED = 8
    MAV_MODE_FLAG_AUTO_ENABLED = 4
    MAV_MODE_FLAG_TEST_ENABLED = 2
    MAV_MODE_FLAG_CUSTOM_MODE_ENABLED = 1

class MAV_MODE_FLAG_DECODE_POSITION(IntEnum):
    MAV_MODE_FLAG_DECODE_POSITION_SAFETY = 128
    MAV_MODE_FLAG_DECODE_POSITION_MANUAL = 64
    MAV_MODE_FLAG_DECODE_POSITION_HIL = 32
    MAV_MODE_FLAG_DECODE_POSITION_STABILIZE = 16
    MAV_MODE_FLAG_DECODE_POSITION_GUIDED = 8
    MAV_MODE_FLAG_DECODE_POSITION_AUTO = 4
    MAV_MODE_FLAG_DECODE_POSITION_TEST = 2
    MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE = 1

class MAV_STATE(IntEnum):
    MAV_STATE_UNINIT = 0
    MAV_STATE_BOOT = 1
    MAV_STATE_CALIBRATING = 2
    MAV_STATE_STANDBY = 3
    MAV_STATE_ACTIVE = 4
    MAV_STATE_CRITICAL = 5
    MAV_STATE_EMERGENCY = 6
    MAV_STATE_POWEROFF = 7
    MAV_STATE_FLIGHT_TERMINATION = 8

class MAV_COMPONENT(IntEnum):
    MAV_COMP_ID_ALL = 0
    MAV_COMP_ID_AUTOPILOT1 = 1
    MAV_COMP_ID_USER1 = 25
    MAV_COMP_ID_USER2 = 26
    MAV_COMP_ID_USER3 = 27
    MAV_COMP_ID_USER4 = 28
    MAV_COMP_ID_USER5 = 29
    MAV_COMP_ID_USER6 = 30
    MAV_COMP_ID_USER7 = 31
    MAV_COMP_ID_USER8 = 32
    MAV_COMP_ID_USER9 = 33
    MAV_COMP_ID_USER10 = 34
    MAV_COMP_ID_USER11 = 35
    MAV_COMP_ID_USER12 = 36
    MAV_COMP_ID_USER13 = 37
    MAV_COMP_ID_USER14 = 38
    MAV_COMP_ID_USER15 = 39
    MAV_COMP_ID_USER16 = 40
    MAV_COMP_ID_USER17 = 41
    MAV_COMP_ID_USER18 = 42
    MAV_COMP_ID_USER19 = 43
    MAV_COMP_ID_USER20 = 44
    MAV_COMP_ID_USER21 = 45
    MAV_COMP_ID_USER22 = 46
    MAV_COMP_ID_USER23 = 47
    MAV_COMP_ID_USER24 = 48
    MAV_COMP_ID_USER25 = 49
    MAV_COMP_ID_USER26 = 50
    MAV_COMP_ID_USER27 = 51
    MAV_COMP_ID_USER28 = 52
    MAV_COMP_ID_USER29 = 53
    MAV_COMP_ID_USER30 = 54
    MAV_COMP_ID_USER31 = 55
    MAV_COMP_ID_USER32 = 56
    MAV_COMP_ID_USER33 = 57
    MAV_COMP_ID_USER34 = 58
    MAV_COMP_ID_USER35 = 59
    MAV_COMP_ID_USER36 = 60
    MAV_COMP_ID_USER37 = 61
    MAV_COMP_ID_USER38 = 62
    MAV_COMP_ID_USER39 = 63
    MAV_COMP_ID_USER40 = 64
    MAV_COMP_ID_USER41 = 65
    MAV_COMP_ID_USER42 = 66
    MAV_COMP_ID_USER43 = 67
    MAV_COMP_ID_TELEMETRY_RADIO = 68
    MAV_COMP_ID_USER45 = 69
    MAV_COMP_ID_USER46 = 70
    MAV_COMP_ID_USER47 = 71
    MAV_COMP_ID_USER48 = 72
    MAV_COMP_ID_USER49 = 73
    MAV_COMP_ID_USER50 = 74
    MAV_COMP_ID_USER51 = 75
    MAV_COMP_ID_USER52 = 76
    MAV_COMP_ID_USER53 = 77
    MAV_COMP_ID_USER54 = 78
    MAV_COMP_ID_USER55 = 79
    MAV_COMP_ID_USER56 = 80
    MAV_COMP_ID_USER57 = 81
    MAV_COMP_ID_USER58 = 82
    MAV_COMP_ID_USER59 = 83
    MAV_COMP_ID_USER60 = 84
    MAV_COMP_ID_USER61 = 85
    MAV_COMP_ID_USER62 = 86
    MAV_COMP_ID_USER63 = 87
    MAV_COMP_ID_USER64 = 88
    MAV_COMP_ID_USER65 = 89
    MAV_COMP_ID_USER66 = 90
    MAV_COMP_ID_USER67 = 91
    MAV_COMP_ID_USER68 = 92
    MAV_COMP_ID_USER69 = 93
    MAV_COMP_ID_USER70 = 94
    MAV_COMP_ID_USER71 = 95
    MAV_COMP_ID_USER72 = 96
    MAV_COMP_ID_USER73 = 97
    MAV_COMP_ID_USER74 = 98
    MAV_COMP_ID_USER75 = 99
    MAV_COMP_ID_CAMERA = 100
    MAV_COMP_ID_CAMERA2 = 101
    MAV_COMP_ID_CAMERA3 = 102
    MAV_COMP_ID_CAMERA4 = 103
    MAV_COMP_ID_CAMERA5 = 104
    MAV_COMP_ID_CAMERA6 = 105
    MAV_COMP_ID_SERVO1 = 140
    MAV_COMP_ID_SERVO2 = 141
    MAV_COMP_ID_SERVO3 = 142
    MAV_COMP_ID_SERVO4 = 143
    MAV_COMP_ID_SERVO5 = 144
    MAV_COMP_ID_SERVO6 = 145
    MAV_COMP_ID_SERVO7 = 146
    MAV_COMP_ID_SERVO8 = 147
    MAV_COMP_ID_SERVO9 = 148
    MAV_COMP_ID_SERVO10 = 149
    MAV_COMP_ID_SERVO11 = 150
    MAV_COMP_ID_SERVO12 = 151
    MAV_COMP_ID_SERVO13 = 152
    MAV_COMP_ID_SERVO14 = 153
    MAV_COMP_ID_GIMBAL = 154
    MAV_COMP_ID_LOG = 155
    MAV_COMP_ID_ADSB = 156
    MAV_COMP_ID_OSD = 157
    MAV_COMP_ID_PERIPHERAL = 158
    MAV_COMP_ID_QX1_GIMBAL = 159
    MAV_COMP_ID_FLARM = 160
    MAV_COMP_ID_PARACHUTE = 161
    MAV_COMP_ID_WINCH = 169
    MAV_COMP_ID_GIMBAL2 = 171
    MAV_COMP_ID_GIMBAL3 = 172
    MAV_COMP_ID_GIMBAL4 = 173
    MAV_COMP_ID_GIMBAL5 = 174
    MAV_COMP_ID_GIMBAL6 = 175
    MAV_COMP_ID_BATTERY = 180
    MAV_COMP_ID_BATTERY2 = 181
    MAV_COMP_ID_MAVCAN = 189
    MAV_COMP_ID_MISSIONPLANNER = 190
    MAV_COMP_ID_ONBOARD_COMPUTER = 191
    MAV_COMP_ID_ONBOARD_COMPUTER2 = 192
    MAV_COMP_ID_ONBOARD_COMPUTER3 = 193
    MAV_COMP_ID_ONBOARD_COMPUTER4 = 194
    MAV_COMP_ID_PATHPLANNER = 195
    MAV_COMP_ID_OBSTACLE_AVOIDANCE = 196
    MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY = 197
    MAV_COMP_ID_PAIRING_MANAGER = 198
    MAV_COMP_ID_IMU = 200
    MAV_COMP_ID_IMU_2 = 201
    MAV_COMP_ID_IMU_3 = 202
    MAV_COMP_ID_GPS = 220
    MAV_COMP_ID_GPS2 = 221
    MAV_COMP_ID_ODID_TXRX_1 = 236
    MAV_COMP_ID_ODID_TXRX_2 = 237
    MAV_COMP_ID_ODID_TXRX_3 = 238
    MAV_COMP_ID_UDP_BRIDGE = 240
    MAV_COMP_ID_UART_BRIDGE = 241
    MAV_COMP_ID_TUNNEL_NODE = 242
    MAV_COMP_ID_ILLUMINATOR = 243
    MAV_COMP_ID_SYSTEM_CONTROL = 250


### Messages ###
@register('SYS_STATUS', 1)
@dataclass
class SysStatus(Unpackable):
    '''
    The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows whether the system is currently active or not and if an emergency occurred. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occurred it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout.
    '''
    onboard_control_sensors_present : MAV_SYS_STATUS_SENSOR
    onboard_control_sensors_enabled : MAV_SYS_STATUS_SENSOR
    onboard_control_sensors_health : MAV_SYS_STATUS_SENSOR
    load : int
    voltage_battery : int
    current_battery : int
    drop_rate_comm : int
    errors_comm : int
    errors_count1 : int
    errors_count2 : int
    errors_count3 : int
    errors_count4 : int
    battery_remaining : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IIIHHhbHHHHHH', data, offset)
        return cls(*args)


@register('SYSTEM_TIME', 2)
@dataclass
class SystemTime(Unpackable):
    '''
    The system time is the time of the master clock, typically the computer clock of the main onboard computer.
    '''
    time_unix_usec : int
    time_boot_ms : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QI', data, offset)
        return cls(*args)


@register('PING', 4)
@dataclass
class Ping(Unpackable):
    '''
    A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections. The ping microservice is documented at https://mavlink.io/en/services/ping.html
    '''
    time_usec : int
    seq : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QIBB', data, offset)
        return cls(*args)


@register('CHANGE_OPERATOR_CONTROL', 5)
@dataclass
class ChangeOperatorControl(Unpackable):
    '''
    Request to control this MAV
    '''
    target_system : int
    control_request : int
    version : int
    passkey : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBB25s', data, offset)
        return cls(*args)


@register('CHANGE_OPERATOR_CONTROL_ACK', 6)
@dataclass
class ChangeOperatorControlAck(Unpackable):
    '''
    Accept / deny control of this MAV
    '''
    gcs_system_id : int
    control_request : int
    ack : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBB', data, offset)
        return cls(*args)


@register('AUTH_KEY', 7)
@dataclass
class AuthKey(Unpackable):
    '''
    Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety.
    '''
    key : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<32s', data, offset)
        return cls(*args)


@register('LINK_NODE_STATUS', 8)
@dataclass
class LinkNodeStatus(Unpackable):
    '''
    Status generated in each node in the communication chain and injected into MAVLink stream.
    '''
    timestamp : int
    tx_rate : int
    rx_rate : int
    messages_sent : int
    messages_received : int
    messages_lost : int
    rx_parse_err : int
    tx_overflows : int
    rx_overflows : int
    tx_buf : int
    rx_buf : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBBIIHHHIII', data, offset)
        return cls(*args)


@register('SET_MODE', 11)
@dataclass
class SetMode(Unpackable):
    '''
    Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component.
    '''
    custom_mode : int
    target_system : int
    base_mode : MAV_MODE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBI', data, offset)
        return cls(*args)


@register('PARAM_REQUEST_READ', 20)
@dataclass
class ParamRequestRead(Unpackable):
    '''
    Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also https://mavlink.io/en/services/parameter.html for a full documentation of QGroundControl and IMU code.
    '''
    param_index : int
    target_system : int
    target_component : int
    param_id : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB16sh', data, offset)
        return cls(*args)


@register('PARAM_REQUEST_LIST', 21)
@dataclass
class ParamRequestList(Unpackable):
    '''
    Request all parameters of this component. After this request, all parameters are emitted. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
    '''
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB', data, offset)
        return cls(*args)


@register('PARAM_VALUE', 22)
@dataclass
class ParamValue(Unpackable):
    '''
    Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
    '''
    param_value : float
    param_count : int
    param_index : int
    param_id : bytes
    param_type : MAV_PARAM_TYPE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<16sfBHH', data, offset)
        return cls(*args)


@register('PARAM_SET', 23)
@dataclass
class ParamSet(Unpackable):
    '''
    Set a parameter value (write new value to permanent storage).
        The receiving component should acknowledge the new parameter value by broadcasting a PARAM_VALUE message (broadcasting ensures that multiple GCS all have an up-to-date list of all parameters). If the sending GCS did not receive a PARAM_VALUE within its timeout time, it should re-send the PARAM_SET message. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html.
    '''
    param_value : float
    target_system : int
    target_component : int
    param_id : bytes
    param_type : MAV_PARAM_TYPE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB16sfB', data, offset)
        return cls(*args)


@register('GPS_RAW_INT', 24)
@dataclass
class GpsRawInt(Unpackable):
    '''
    The global position, as returned by the Global Positioning System (GPS). This is
                NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION_INT for the global position estimate.
    '''
    time_usec : int
    lat : int
    lon : int
    alt : int
    eph : int
    epv : int
    vel : int
    cog : int
    fix_type : GPS_FIX_TYPE
    satellites_visible : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBiiiHHHHB', data, offset)
        return cls(*args)


@register('GPS_STATUS', 25)
@dataclass
class GpsStatus(Unpackable):
    '''
    The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION_INT for the global position estimate. This message can contain information for up to 20 satellites.
    '''
    satellites_visible : int
    satellite_prn : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    satellite_used : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    satellite_elevation : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    satellite_azimuth : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    satellite_snr : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<B20s20s20s20s20s', data, offset)
        args[1] = tuple(*struct.unpack('<20B', args[1]))
        args[2] = tuple(*struct.unpack('<20B', args[2]))
        args[3] = tuple(*struct.unpack('<20B', args[3]))
        args[4] = tuple(*struct.unpack('<20B', args[4]))
        args[5] = tuple(*struct.unpack('<20B', args[5]))
        return cls(*args)


@register('SCALED_IMU', 26)
@dataclass
class ScaledImu(Unpackable):
    '''
    The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units
    '''
    time_boot_ms : int
    xacc : int
    yacc : int
    zacc : int
    xgyro : int
    ygyro : int
    zgyro : int
    xmag : int
    ymag : int
    zmag : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Ihhhhhhhhh', data, offset)
        return cls(*args)


@register('RAW_IMU', 27)
@dataclass
class RawImu(Unpackable):
    '''
    The RAW IMU readings for a 9DOF sensor, which is identified by the id (default IMU1). This message should always contain the true raw values without any scaling to allow data capture and system debugging.
    '''
    time_usec : int
    xacc : int
    yacc : int
    zacc : int
    xgyro : int
    ygyro : int
    zgyro : int
    xmag : int
    ymag : int
    zmag : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qhhhhhhhhh', data, offset)
        return cls(*args)


@register('RAW_PRESSURE', 28)
@dataclass
class RawPressure(Unpackable):
    '''
    The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values.
    '''
    time_usec : int
    press_abs : int
    press_diff1 : int
    press_diff2 : int
    temperature : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qhhhh', data, offset)
        return cls(*args)


@register('SCALED_PRESSURE', 29)
@dataclass
class ScaledPressure(Unpackable):
    '''
    The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field.
    '''
    time_boot_ms : int
    press_abs : float
    press_diff : float
    temperature : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Iffh', data, offset)
        return cls(*args)


@register('ATTITUDE', 30)
@dataclass
class Attitude(Unpackable):
    '''
    The attitude in the aeronautical frame (right-handed, Z-down, Y-right, X-front, ZYX, intrinsic).
    '''
    time_boot_ms : int
    roll : float
    pitch : float
    yaw : float
    rollspeed : float
    pitchspeed : float
    yawspeed : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Iffffff', data, offset)
        return cls(*args)


@register('ATTITUDE_QUATERNION', 31)
@dataclass
class AttitudeQuaternion(Unpackable):
    '''
    The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
    '''
    time_boot_ms : int
    q1 : float
    q2 : float
    q3 : float
    q4 : float
    rollspeed : float
    pitchspeed : float
    yawspeed : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Ifffffff', data, offset)
        return cls(*args)


@register('LOCAL_POSITION_NED', 32)
@dataclass
class LocalPositionNed(Unpackable):
    '''
    The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    '''
    time_boot_ms : int
    x : float
    y : float
    z : float
    vx : float
    vy : float
    vz : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Iffffff', data, offset)
        return cls(*args)


@register('GLOBAL_POSITION_INT', 33)
@dataclass
class GlobalPositionInt(Unpackable):
    '''
    The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It
               is designed as scaled integer message since the resolution of float is not sufficient.
    '''
    time_boot_ms : int
    lat : int
    lon : int
    alt : int
    relative_alt : int
    vx : int
    vy : int
    vz : int
    hdg : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IiiiihhhH', data, offset)
        return cls(*args)


@register('RC_CHANNELS_SCALED', 34)
@dataclass
class RcChannelsScaled(Unpackable):
    '''
    The scaled values of the RC channels received: (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to INT16_MAX.
    '''
    time_boot_ms : int
    chan1_scaled : int
    chan2_scaled : int
    chan3_scaled : int
    chan4_scaled : int
    chan5_scaled : int
    chan6_scaled : int
    chan7_scaled : int
    chan8_scaled : int
    port : int
    rssi : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBhhhhhhhhB', data, offset)
        return cls(*args)


@register('RC_CHANNELS_RAW', 35)
@dataclass
class RcChannelsRaw(Unpackable):
    '''
    The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification.
    '''
    time_boot_ms : int
    chan1_raw : int
    chan2_raw : int
    chan3_raw : int
    chan4_raw : int
    chan5_raw : int
    chan6_raw : int
    chan7_raw : int
    chan8_raw : int
    port : int
    rssi : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBHHHHHHHHB', data, offset)
        return cls(*args)


@register('SERVO_OUTPUT_RAW', 36)
@dataclass
class ServoOutputRaw(Unpackable):
    '''
    Superseded by ACTUATOR_OUTPUT_STATUS. The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.
    '''
    time_usec : int
    servo1_raw : int
    servo2_raw : int
    servo3_raw : int
    servo4_raw : int
    servo5_raw : int
    servo6_raw : int
    servo7_raw : int
    servo8_raw : int
    port : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBHHHHHHHH', data, offset)
        return cls(*args)


@register('MISSION_REQUEST_PARTIAL_LIST', 37)
@dataclass
class MissionRequestPartialList(Unpackable):
    '''
    Request a partial list of mission items from the system/component. https://mavlink.io/en/services/mission.html. If start and end index are the same, just send one waypoint.
    '''
    start_index : int
    end_index : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBhh', data, offset)
        return cls(*args)


@register('MISSION_WRITE_PARTIAL_LIST', 38)
@dataclass
class MissionWritePartialList(Unpackable):
    '''
    This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED!
    '''
    start_index : int
    end_index : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBhh', data, offset)
        return cls(*args)


@register('MISSION_ITEM', 39)
@dataclass
class MissionItem(Unpackable):
    '''
    Message encoding a mission item. This message is emitted to announce
                the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN may be used to indicate an optional/default value (e.g. to use the system's current latitude or yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html.
    '''
    param1 : float
    param2 : float
    param3 : float
    param4 : float
    x : float
    y : float
    z : float
    seq : int
    command : MAV_CMD
    target_system : int
    target_component : int
    frame : MAV_FRAME
    current : int
    autocontinue : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHBHBBfffffff', data, offset)
        return cls(*args)


@register('MISSION_REQUEST', 40)
@dataclass
class MissionRequest(Unpackable):
    '''
    Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. https://mavlink.io/en/services/mission.html
    '''
    seq : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBH', data, offset)
        return cls(*args)


@register('MISSION_SET_CURRENT', 41)
@dataclass
class MissionSetCurrent(Unpackable):
    '''
    Set the mission item with sequence number seq as the current item and emit MISSION_CURRENT (whether or not the mission number changed).
        If a mission is currently being executed, the system will continue to this new mission item on the shortest path, skipping any intermediate mission items.
        Note that mission jump repeat counters are not reset (see MAV_CMD_DO_JUMP param2).

        This message may trigger a mission state-machine change on some systems: for example from MISSION_STATE_NOT_STARTED or MISSION_STATE_PAUSED to MISSION_STATE_ACTIVE.
        If the system is in mission mode, on those systems this command might therefore start, restart or resume the mission.
        If the system is not in mission mode this message must not trigger a switch to mission mode.
    '''
    seq : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBH', data, offset)
        return cls(*args)


@register('MISSION_CURRENT', 42)
@dataclass
class MissionCurrent(Unpackable):
    '''
    Message that announces the sequence number of the current target mission item (that the system will fly towards/execute when the mission is running).
        This message should be streamed all the time (nominally at 1Hz).
        This message should be emitted following a call to MAV_CMD_DO_SET_MISSION_CURRENT or SET_MISSION_CURRENT.
    '''
    seq : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<H', data, offset)
        return cls(*args)


@register('MISSION_REQUEST_LIST', 43)
@dataclass
class MissionRequestList(Unpackable):
    '''
    Request the overall list of mission items from the system/component.
    '''
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB', data, offset)
        return cls(*args)


@register('MISSION_COUNT', 44)
@dataclass
class MissionCount(Unpackable):
    '''
    This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of waypoints.
    '''
    count : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBH', data, offset)
        return cls(*args)


@register('MISSION_CLEAR_ALL', 45)
@dataclass
class MissionClearAll(Unpackable):
    '''
    Delete all mission items at once.
    '''
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB', data, offset)
        return cls(*args)


@register('MISSION_ITEM_REACHED', 46)
@dataclass
class MissionItemReached(Unpackable):
    '''
    A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next waypoint.
    '''
    seq : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<H', data, offset)
        return cls(*args)


@register('MISSION_ACK', 47)
@dataclass
class MissionAck(Unpackable):
    '''
    Acknowledgment message during waypoint handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero).
    '''
    target_system : int
    target_component : int
    type : MAV_MISSION_RESULT

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBB', data, offset)
        return cls(*args)


@register('SET_GPS_GLOBAL_ORIGIN', 48)
@dataclass
class SetGpsGlobalOrigin(Unpackable):
    '''
    Sets the GPS coordinates of the vehicle local origin (0,0,0) position. Vehicle should emit GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the local coordinate frame and the global (GPS) coordinate frame, which may be necessary when (for example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor.
    '''
    latitude : int
    longitude : int
    altitude : int
    target_system : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Biii', data, offset)
        return cls(*args)


@register('GPS_GLOBAL_ORIGIN', 49)
@dataclass
class GpsGlobalOrigin(Unpackable):
    '''
    Publishes the GPS coordinates of the vehicle local origin (0,0,0) position. Emitted whenever a new GPS-Local position mapping is requested or set - e.g. following SET_GPS_GLOBAL_ORIGIN message.
    '''
    latitude : int
    longitude : int
    altitude : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<iii', data, offset)
        return cls(*args)


@register('PARAM_MAP_RC', 50)
@dataclass
class ParamMapRc(Unpackable):
    '''
    Bind a RC channel to a parameter. The parameter should change according to the RC channel value.
    '''
    param_value0 : float
    scale : float
    param_value_min : float
    param_value_max : float
    param_index : int
    target_system : int
    target_component : int
    param_id : bytes
    parameter_rc_channel_index : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB16shBffff', data, offset)
        return cls(*args)


@register('MISSION_REQUEST_INT', 51)
@dataclass
class MissionRequestInt(Unpackable):
    '''
    Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM_INT message. https://mavlink.io/en/services/mission.html
    '''
    seq : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBH', data, offset)
        return cls(*args)


@register('SAFETY_SET_ALLOWED_AREA', 54)
@dataclass
class SafetySetAllowedArea(Unpackable):
    '''
    Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/waypoints to accept and which to reject. Safety areas are often enforced by national or competition regulations.
    '''
    p1x : float
    p1y : float
    p1z : float
    p2x : float
    p2y : float
    p2z : float
    target_system : int
    target_component : int
    frame : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBffffff', data, offset)
        return cls(*args)


@register('SAFETY_ALLOWED_AREA', 55)
@dataclass
class SafetyAllowedArea(Unpackable):
    '''
    Read out the safety zone the MAV currently assumes.
    '''
    p1x : float
    p1y : float
    p1z : float
    p2x : float
    p2y : float
    p2z : float
    frame : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Bffffff', data, offset)
        return cls(*args)


@register('ATTITUDE_QUATERNION_COV', 61)
@dataclass
class AttitudeQuaternionCov(Unpackable):
    '''
    The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
    '''
    time_usec : int
    q : Tuple[float,float,float,float]
    rollspeed : float
    pitchspeed : float
    yawspeed : float
    covariance : Tuple[float,float,float,float,float,float,float,float,float]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Q16sfff36s', data, offset)
        args[1] = tuple(*struct.unpack('<4f', args[1]))
        args[5] = tuple(*struct.unpack('<9f', args[5]))
        return cls(*args)


@register('NAV_CONTROLLER_OUTPUT', 62)
@dataclass
class NavControllerOutput(Unpackable):
    '''
    The state of the navigation and position controller.
    '''
    nav_roll : float
    nav_pitch : float
    alt_error : float
    aspd_error : float
    xtrack_error : float
    nav_bearing : int
    target_bearing : int
    wp_dist : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<ffhhHfff', data, offset)
        return cls(*args)


@register('GLOBAL_POSITION_INT_COV', 63)
@dataclass
class GlobalPositionIntCov(Unpackable):
    '''
    The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset.
    '''
    time_usec : int
    lat : int
    lon : int
    alt : int
    relative_alt : int
    vx : float
    vy : float
    vz : float
    covariance : Tuple[float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float]
    estimator_type : MAV_ESTIMATOR_TYPE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBiiiifff144s', data, offset)
        args[9] = tuple(*struct.unpack('<36f', args[9]))
        return cls(*args)


@register('LOCAL_POSITION_NED_COV', 64)
@dataclass
class LocalPositionNedCov(Unpackable):
    '''
    The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    '''
    time_usec : int
    x : float
    y : float
    z : float
    vx : float
    vy : float
    vz : float
    ax : float
    ay : float
    az : float
    covariance : Tuple[float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float]
    estimator_type : MAV_ESTIMATOR_TYPE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBfffffffff180s', data, offset)
        args[11] = tuple(*struct.unpack('<45f', args[11]))
        return cls(*args)


@register('RC_CHANNELS', 65)
@dataclass
class RcChannels(Unpackable):
    '''
    The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.  A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification.
    '''
    time_boot_ms : int
    chan1_raw : int
    chan2_raw : int
    chan3_raw : int
    chan4_raw : int
    chan5_raw : int
    chan6_raw : int
    chan7_raw : int
    chan8_raw : int
    chan9_raw : int
    chan10_raw : int
    chan11_raw : int
    chan12_raw : int
    chan13_raw : int
    chan14_raw : int
    chan15_raw : int
    chan16_raw : int
    chan17_raw : int
    chan18_raw : int
    chancount : int
    rssi : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBHHHHHHHHHHHHHHHHHHB', data, offset)
        return cls(*args)


@register('REQUEST_DATA_STREAM', 66)
@dataclass
class RequestDataStream(Unpackable):
    '''
    Request a data stream.
    '''
    req_message_rate : int
    target_system : int
    target_component : int
    req_stream_id : int
    start_stop : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBHB', data, offset)
        return cls(*args)


@register('DATA_STREAM', 67)
@dataclass
class DataStream(Unpackable):
    '''
    Data stream status information.
    '''
    message_rate : int
    stream_id : int
    on_off : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BHB', data, offset)
        return cls(*args)


@register('MANUAL_CONTROL', 69)
@dataclass
class ManualControl(Unpackable):
    '''
    This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled and buttons states are transmitted as individual on/off bits of a bitmask
    '''
    x : int
    y : int
    z : int
    r : int
    buttons : int
    target : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BhhhhH', data, offset)
        return cls(*args)


@register('RC_CHANNELS_OVERRIDE', 70)
@dataclass
class RcChannelsOverride(Unpackable):
    '''
    The RAW values of the RC channels sent to the MAV to override info received from the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.  Note carefully the semantic differences between the first 8 channels and the subsequent channels
    '''
    chan1_raw : int
    chan2_raw : int
    chan3_raw : int
    chan4_raw : int
    chan5_raw : int
    chan6_raw : int
    chan7_raw : int
    chan8_raw : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHHHHHHHH', data, offset)
        return cls(*args)


@register('MISSION_ITEM_INT', 73)
@dataclass
class MissionItemInt(Unpackable):
    '''
    Message encoding a mission item. This message is emitted to announce
                the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html.
    '''
    param1 : float
    param2 : float
    param3 : float
    param4 : float
    x : int
    y : int
    z : float
    seq : int
    command : MAV_CMD
    target_system : int
    target_component : int
    frame : MAV_FRAME
    current : int
    autocontinue : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHBHBBffffiif', data, offset)
        return cls(*args)


@register('VFR_HUD', 74)
@dataclass
class VfrHud(Unpackable):
    '''
    Metrics typically displayed on a HUD for fixed wing aircraft.
    '''
    airspeed : float
    groundspeed : float
    alt : float
    climb : float
    heading : int
    throttle : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<ffhHff', data, offset)
        return cls(*args)


@register('COMMAND_INT', 75)
@dataclass
class CommandInt(Unpackable):
    '''
    Send a command with up to seven parameters to the MAV, where params 5 and 6 are integers and the other values are floats. This is preferred over COMMAND_LONG as it allows the MAV_FRAME to be specified for interpreting positional information, such as altitude. COMMAND_INT is also preferred when sending latitude and longitude data in params 5 and 6, as it allows for greater precision. Param 5 and 6 encode positional data as scaled integers, where the scaling depends on the actual command value. NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). The command microservice is documented at https://mavlink.io/en/services/command.html
    '''
    param1 : float
    param2 : float
    param3 : float
    param4 : float
    x : int
    y : int
    z : float
    command : MAV_CMD
    target_system : int
    target_component : int
    frame : MAV_FRAME
    current : int
    autocontinue : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBHBBffffiif', data, offset)
        return cls(*args)


@register('COMMAND_LONG', 76)
@dataclass
class CommandLong(Unpackable):
    '''
    Send a command with up to seven parameters to the MAV. COMMAND_INT is generally preferred when sending MAV_CMD commands that include positional information; it offers higher precision and allows the MAV_FRAME to be specified (which may otherwise be ambiguous, particularly for altitude). The command microservice is documented at https://mavlink.io/en/services/command.html
    '''
    param1 : float
    param2 : float
    param3 : float
    param4 : float
    param5 : float
    param6 : float
    param7 : float
    command : MAV_CMD
    target_system : int
    target_component : int
    confirmation : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHBfffffff', data, offset)
        return cls(*args)


@register('COMMAND_ACK', 77)
@dataclass
class CommandAck(Unpackable):
    '''
    Report status of a command. Includes feedback whether the command was executed. The command microservice is documented at https://mavlink.io/en/services/command.html
    '''
    command : MAV_CMD
    result : MAV_RESULT

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<HB', data, offset)
        return cls(*args)


@register('COMMAND_CANCEL', 80)
@dataclass
class CommandCancel(Unpackable):
    '''
    Cancel a long running command. The target system should respond with a COMMAND_ACK to the original command with result=MAV_RESULT_CANCELLED if the long running process was cancelled. If it has already completed, the cancel action can be ignored. The cancel action can be retried until some sort of acknowledgement to the original command has been received. The command microservice is documented at https://mavlink.io/en/services/command.html
    '''
    command : MAV_CMD
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBH', data, offset)
        return cls(*args)


@register('MANUAL_SETPOINT', 81)
@dataclass
class ManualSetpoint(Unpackable):
    '''
    Setpoint in roll, pitch, yaw and thrust from the operator
    '''
    time_boot_ms : int
    roll : float
    pitch : float
    yaw : float
    thrust : float
    mode_switch : int
    manual_override_switch : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IffffBB', data, offset)
        return cls(*args)


@register('SET_ATTITUDE_TARGET', 82)
@dataclass
class SetAttitudeTarget(Unpackable):
    '''
    Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller or other system).
    '''
    time_boot_ms : int
    q : Tuple[float,float,float,float]
    body_roll_rate : float
    body_pitch_rate : float
    body_yaw_rate : float
    thrust : float
    target_system : int
    target_component : int
    type_mask : ATTITUDE_TARGET_TYPEMASK

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBBB16sffff', data, offset)
        args[4] = tuple(*struct.unpack('<4f', args[4]))
        return cls(*args)


@register('ATTITUDE_TARGET', 83)
@dataclass
class AttitudeTarget(Unpackable):
    '''
    Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way.
    '''
    time_boot_ms : int
    q : Tuple[float,float,float,float]
    body_roll_rate : float
    body_pitch_rate : float
    body_yaw_rate : float
    thrust : float
    type_mask : ATTITUDE_TARGET_TYPEMASK

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IB16sffff', data, offset)
        args[2] = tuple(*struct.unpack('<4f', args[2]))
        return cls(*args)


@register('SET_POSITION_TARGET_LOCAL_NED', 84)
@dataclass
class SetPositionTargetLocalNed(Unpackable):
    '''
    Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller to command the vehicle (manual controller or other system).
    '''
    time_boot_ms : int
    x : float
    y : float
    z : float
    vx : float
    vy : float
    vz : float
    afx : float
    afy : float
    afz : float
    yaw : float
    yaw_rate : float
    type_mask : POSITION_TARGET_TYPEMASK
    target_system : int
    target_component : int
    coordinate_frame : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBBBHfffffffffff', data, offset)
        return cls(*args)


@register('POSITION_TARGET_LOCAL_NED', 85)
@dataclass
class PositionTargetLocalNed(Unpackable):
    '''
    Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled this way.
    '''
    time_boot_ms : int
    x : float
    y : float
    z : float
    vx : float
    vy : float
    vz : float
    afx : float
    afy : float
    afz : float
    yaw : float
    yaw_rate : float
    type_mask : POSITION_TARGET_TYPEMASK
    coordinate_frame : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBHfffffffffff', data, offset)
        return cls(*args)


@register('SET_POSITION_TARGET_GLOBAL_INT', 86)
@dataclass
class SetPositionTargetGlobalInt(Unpackable):
    '''
    Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84). Used by an external controller to command the vehicle (manual controller or other system).
    '''
    time_boot_ms : int
    lat_int : int
    lon_int : int
    alt : float
    vx : float
    vy : float
    vz : float
    afx : float
    afy : float
    afz : float
    yaw : float
    yaw_rate : float
    type_mask : POSITION_TARGET_TYPEMASK
    target_system : int
    target_component : int
    coordinate_frame : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBBBHiifffffffff', data, offset)
        return cls(*args)


@register('POSITION_TARGET_GLOBAL_INT', 87)
@dataclass
class PositionTargetGlobalInt(Unpackable):
    '''
    Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way.
    '''
    time_boot_ms : int
    lat_int : int
    lon_int : int
    alt : float
    vx : float
    vy : float
    vz : float
    afx : float
    afy : float
    afz : float
    yaw : float
    yaw_rate : float
    type_mask : POSITION_TARGET_TYPEMASK
    coordinate_frame : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBHiifffffffff', data, offset)
        return cls(*args)


@register('LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET', 89)
@dataclass
class LocalPositionNedSystemGlobalOffset(Unpackable):
    '''
    The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    '''
    time_boot_ms : int
    x : float
    y : float
    z : float
    roll : float
    pitch : float
    yaw : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Iffffff', data, offset)
        return cls(*args)


@register('HIL_STATE', 90)
@dataclass
class HilState(Unpackable):
    '''
    Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations.
    '''
    time_usec : int
    roll : float
    pitch : float
    yaw : float
    rollspeed : float
    pitchspeed : float
    yawspeed : float
    lat : int
    lon : int
    alt : int
    vx : int
    vy : int
    vz : int
    xacc : int
    yacc : int
    zacc : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qffffffiiihhhhhh', data, offset)
        return cls(*args)


@register('HIL_CONTROLS', 91)
@dataclass
class HilControls(Unpackable):
    '''
    Sent from autopilot to simulation. Hardware in the loop control outputs
    '''
    time_usec : int
    roll_ailerons : float
    pitch_elevator : float
    yaw_rudder : float
    throttle : float
    aux1 : float
    aux2 : float
    aux3 : float
    aux4 : float
    mode : MAV_MODE
    nav_mode : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QffffffffBB', data, offset)
        return cls(*args)


@register('HIL_RC_INPUTS_RAW', 92)
@dataclass
class HilRcInputsRaw(Unpackable):
    '''
    Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
    '''
    time_usec : int
    chan1_raw : int
    chan2_raw : int
    chan3_raw : int
    chan4_raw : int
    chan5_raw : int
    chan6_raw : int
    chan7_raw : int
    chan8_raw : int
    chan9_raw : int
    chan10_raw : int
    chan11_raw : int
    chan12_raw : int
    rssi : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QHHHHHHHHHHHHB', data, offset)
        return cls(*args)


@register('HIL_ACTUATOR_CONTROLS', 93)
@dataclass
class HilActuatorControls(Unpackable):
    '''
    Sent from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS)
    '''
    time_usec : int
    flags : int
    controls : Tuple[float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float]
    mode : MAV_MODE_FLAG

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Q64sBQ', data, offset)
        args[1] = tuple(*struct.unpack('<16f', args[1]))
        return cls(*args)


@register('OPTICAL_FLOW', 100)
@dataclass
class OpticalFlow(Unpackable):
    '''
    Optical flow from a flow sensor (e.g. optical mouse sensor)
    '''
    time_usec : int
    flow_comp_m_x : float
    flow_comp_m_y : float
    ground_distance : float
    flow_x : int
    flow_y : int
    sensor_id : int
    quality : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBhhffBf', data, offset)
        return cls(*args)


@register('GLOBAL_VISION_POSITION_ESTIMATE', 101)
@dataclass
class GlobalVisionPositionEstimate(Unpackable):
    '''
    Global position/attitude estimate from a vision source.
    '''
    usec : int
    x : float
    y : float
    z : float
    roll : float
    pitch : float
    yaw : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qffffff', data, offset)
        return cls(*args)


@register('VISION_POSITION_ESTIMATE', 102)
@dataclass
class VisionPositionEstimate(Unpackable):
    '''
    Local position/attitude estimate from a vision source.
    '''
    usec : int
    x : float
    y : float
    z : float
    roll : float
    pitch : float
    yaw : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qffffff', data, offset)
        return cls(*args)


@register('VISION_SPEED_ESTIMATE', 103)
@dataclass
class VisionSpeedEstimate(Unpackable):
    '''
    Speed estimate from a vision source.
    '''
    usec : int
    x : float
    y : float
    z : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qfff', data, offset)
        return cls(*args)


@register('VICON_POSITION_ESTIMATE', 104)
@dataclass
class ViconPositionEstimate(Unpackable):
    '''
    Global position estimate from a Vicon motion system source.
    '''
    usec : int
    x : float
    y : float
    z : float
    roll : float
    pitch : float
    yaw : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qffffff', data, offset)
        return cls(*args)


@register('HIGHRES_IMU', 105)
@dataclass
class HighresImu(Unpackable):
    '''
    The IMU readings in SI units in NED body frame
    '''
    time_usec : int
    xacc : float
    yacc : float
    zacc : float
    xgyro : float
    ygyro : float
    zgyro : float
    xmag : float
    ymag : float
    zmag : float
    abs_pressure : float
    diff_pressure : float
    pressure_alt : float
    temperature : float
    fields_updated : HIGHRES_IMU_UPDATED_FLAGS

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QfffffffffffffH', data, offset)
        return cls(*args)


@register('OPTICAL_FLOW_RAD', 106)
@dataclass
class OpticalFlowRad(Unpackable):
    '''
    Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor)
    '''
    time_usec : int
    integration_time_us : int
    integrated_x : float
    integrated_y : float
    integrated_xgyro : float
    integrated_ygyro : float
    integrated_zgyro : float
    time_delta_distance_us : int
    distance : float
    temperature : int
    sensor_id : int
    quality : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBIfffffhBIf', data, offset)
        return cls(*args)


@register('HIL_SENSOR', 107)
@dataclass
class HilSensor(Unpackable):
    '''
    The IMU readings in SI units in NED body frame
    '''
    time_usec : int
    xacc : float
    yacc : float
    zacc : float
    xgyro : float
    ygyro : float
    zgyro : float
    xmag : float
    ymag : float
    zmag : float
    abs_pressure : float
    diff_pressure : float
    pressure_alt : float
    temperature : float
    fields_updated : HIL_SENSOR_UPDATED_FLAGS

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QfffffffffffffI', data, offset)
        return cls(*args)


@register('SIM_STATE', 108)
@dataclass
class SimState(Unpackable):
    '''
    Status of simulation environment, if used
    '''
    q1 : float
    q2 : float
    q3 : float
    q4 : float
    roll : float
    pitch : float
    yaw : float
    xacc : float
    yacc : float
    zacc : float
    xgyro : float
    ygyro : float
    zgyro : float
    lat : float
    lon : float
    alt : float
    std_dev_horz : float
    std_dev_vert : float
    vn : float
    ve : float
    vd : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<fffffffffffffffffffff', data, offset)
        return cls(*args)


@register('RADIO_STATUS', 109)
@dataclass
class RadioStatus(Unpackable):
    '''
    Status generated by radio and injected into MAVLink stream.
    '''
    rxerrors : int
    fixed : int
    rssi : int
    remrssi : int
    txbuf : int
    noise : int
    remnoise : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBBBHH', data, offset)
        return cls(*args)


@register('FILE_TRANSFER_PROTOCOL', 110)
@dataclass
class FileTransferProtocol(Unpackable):
    '''
    File transfer protocol message: https://mavlink.io/en/services/ftp.html.
    '''
    target_network : int
    target_system : int
    target_component : int
    payload : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBB251s', data, offset)
        args[3] = tuple(*struct.unpack('<251B', args[3]))
        return cls(*args)


@register('TIMESYNC', 111)
@dataclass
class Timesync(Unpackable):
    '''
    Time synchronization message.
        The message is used for both timesync requests and responses.
        The request is sent with `ts1=syncing component timestamp` and `tc1=0`, and may be broadcast or targeted to a specific system/component.
        The response is sent with `ts1=syncing component timestamp` (mirror back unchanged), and `tc1=responding component timestamp`, with the `target_system` and `target_component` set to ids of the original request.
        Systems can determine if they are receiving a request or response based on the value of `tc`.
        If the response has `target_system==target_component==0` the remote system has not been updated to use the component IDs and cannot reliably timesync; the requestor may report an error.
        Timestamps are UNIX Epoch time or time since system boot in nanoseconds (the timestamp format can be inferred by checking for the magnitude of the number; generally it doesn't matter as only the offset is used).
        The message sequence is repeated numerous times with results being filtered/averaged to estimate the offset.
    '''
    tc1 : int
    ts1 : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<qq', data, offset)
        return cls(*args)


@register('CAMERA_TRIGGER', 112)
@dataclass
class CameraTrigger(Unpackable):
    '''
    Camera-IMU triggering and synchronisation message.
    '''
    time_usec : int
    seq : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QI', data, offset)
        return cls(*args)


@register('HIL_GPS', 113)
@dataclass
class HilGps(Unpackable):
    '''
    The global position, as returned by the Global Positioning System (GPS). This is
                 NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION_INT for the global position estimate.
    '''
    time_usec : int
    lat : int
    lon : int
    alt : int
    eph : int
    epv : int
    vel : int
    vn : int
    ve : int
    vd : int
    cog : int
    fix_type : int
    satellites_visible : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBiiiHHHhhhHB', data, offset)
        return cls(*args)


@register('HIL_OPTICAL_FLOW', 114)
@dataclass
class HilOpticalFlow(Unpackable):
    '''
    Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor)
    '''
    time_usec : int
    integration_time_us : int
    integrated_x : float
    integrated_y : float
    integrated_xgyro : float
    integrated_ygyro : float
    integrated_zgyro : float
    time_delta_distance_us : int
    distance : float
    temperature : int
    sensor_id : int
    quality : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBIfffffhBIf', data, offset)
        return cls(*args)


@register('HIL_STATE_QUATERNION', 115)
@dataclass
class HilStateQuaternion(Unpackable):
    '''
    Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations.
    '''
    time_usec : int
    attitude_quaternion : Tuple[float,float,float,float]
    rollspeed : float
    pitchspeed : float
    yawspeed : float
    lat : int
    lon : int
    alt : int
    vx : int
    vy : int
    vz : int
    ind_airspeed : int
    true_airspeed : int
    xacc : int
    yacc : int
    zacc : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Q16sfffiiihhhHHhhh', data, offset)
        args[1] = tuple(*struct.unpack('<4f', args[1]))
        return cls(*args)


@register('SCALED_IMU2', 116)
@dataclass
class ScaledImu2(Unpackable):
    '''
    The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units
    '''
    time_boot_ms : int
    xacc : int
    yacc : int
    zacc : int
    xgyro : int
    ygyro : int
    zgyro : int
    xmag : int
    ymag : int
    zmag : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Ihhhhhhhhh', data, offset)
        return cls(*args)


@register('LOG_REQUEST_LIST', 117)
@dataclass
class LogRequestList(Unpackable):
    '''
    Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called. If there are no log files available this request shall be answered with one LOG_ENTRY message with id = 0 and num_logs = 0.
    '''
    start : int
    end : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHH', data, offset)
        return cls(*args)


@register('LOG_ENTRY', 118)
@dataclass
class LogEntry(Unpackable):
    '''
    Reply to LOG_REQUEST_LIST
    '''
    time_utc : int
    size : int
    id : int
    num_logs : int
    last_log_num : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<HHHII', data, offset)
        return cls(*args)


@register('LOG_REQUEST_DATA', 119)
@dataclass
class LogRequestData(Unpackable):
    '''
    Request a chunk of a log
    '''
    ofs : int
    count : int
    id : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHII', data, offset)
        return cls(*args)


@register('LOG_DATA', 120)
@dataclass
class LogData(Unpackable):
    '''
    Reply to LOG_REQUEST_DATA
    '''
    ofs : int
    id : int
    count : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<HIB90s', data, offset)
        args[3] = tuple(*struct.unpack('<90B', args[3]))
        return cls(*args)


@register('LOG_ERASE', 121)
@dataclass
class LogErase(Unpackable):
    '''
    Erase all logs
    '''
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB', data, offset)
        return cls(*args)


@register('LOG_REQUEST_END', 122)
@dataclass
class LogRequestEnd(Unpackable):
    '''
    Stop log transfer and resume normal logging
    '''
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB', data, offset)
        return cls(*args)


@register('GPS_INJECT_DATA', 123)
@dataclass
class GpsInjectData(Unpackable):
    '''
    Data for injecting into the onboard GPS (used for DGPS)
    '''
    target_system : int
    target_component : int
    len : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBB110s', data, offset)
        args[3] = tuple(*struct.unpack('<110B', args[3]))
        return cls(*args)


@register('GPS2_RAW', 124)
@dataclass
class Gps2Raw(Unpackable):
    '''
    Second GPS data.
    '''
    time_usec : int
    lat : int
    lon : int
    alt : int
    dgps_age : int
    eph : int
    epv : int
    vel : int
    cog : int
    fix_type : GPS_FIX_TYPE
    satellites_visible : int
    dgps_numch : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBiiiHHHHBBI', data, offset)
        return cls(*args)


@register('POWER_STATUS', 125)
@dataclass
class PowerStatus(Unpackable):
    '''
    Power supply status
    '''
    Vcc : int
    Vservo : int
    flags : MAV_POWER_STATUS

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<HHH', data, offset)
        return cls(*args)


@register('SERIAL_CONTROL', 126)
@dataclass
class SerialControl(Unpackable):
    '''
    Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate.
    '''
    baudrate : int
    timeout : int
    device : SERIAL_CONTROL_DEV
    flags : SERIAL_CONTROL_FLAG
    count : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHIB70s', data, offset)
        args[5] = tuple(*struct.unpack('<70B', args[5]))
        return cls(*args)


@register('GPS_RTK', 127)
@dataclass
class GpsRtk(Unpackable):
    '''
    RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
    '''
    time_last_baseline_ms : int
    tow : int
    baseline_a_mm : int
    baseline_b_mm : int
    baseline_c_mm : int
    accuracy : int
    iar_num_hypotheses : int
    wn : int
    rtk_receiver_id : int
    rtk_health : int
    rtk_rate : int
    nsats : int
    baseline_coords_type : RTK_BASELINE_COORDINATE_SYSTEM

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBHIBBBBiiiIi', data, offset)
        return cls(*args)


@register('GPS2_RTK', 128)
@dataclass
class Gps2Rtk(Unpackable):
    '''
    RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
    '''
    time_last_baseline_ms : int
    tow : int
    baseline_a_mm : int
    baseline_b_mm : int
    baseline_c_mm : int
    accuracy : int
    iar_num_hypotheses : int
    wn : int
    rtk_receiver_id : int
    rtk_health : int
    rtk_rate : int
    nsats : int
    baseline_coords_type : RTK_BASELINE_COORDINATE_SYSTEM

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBHIBBBBiiiIi', data, offset)
        return cls(*args)


@register('SCALED_IMU3', 129)
@dataclass
class ScaledImu3(Unpackable):
    '''
    The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described units
    '''
    time_boot_ms : int
    xacc : int
    yacc : int
    zacc : int
    xgyro : int
    ygyro : int
    zgyro : int
    xmag : int
    ymag : int
    zmag : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Ihhhhhhhhh', data, offset)
        return cls(*args)


@register('DATA_TRANSMISSION_HANDSHAKE', 130)
@dataclass
class DataTransmissionHandshake(Unpackable):
    '''
    Handshake message to initiate, control and stop image streaming when using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html.
    '''
    size : int
    width : int
    height : int
    packets : int
    type : MAVLINK_DATA_STREAM_TYPE
    payload : int
    jpg_quality : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BIHHHBB', data, offset)
        return cls(*args)


@register('ENCAPSULATED_DATA', 131)
@dataclass
class EncapsulatedData(Unpackable):
    '''
    Data packet for images sent using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html.
    '''
    seqnr : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<H253s', data, offset)
        args[1] = tuple(*struct.unpack('<253B', args[1]))
        return cls(*args)


@register('DISTANCE_SENSOR', 132)
@dataclass
class DistanceSensor(Unpackable):
    '''
    Distance sensor information for an onboard rangefinder.
    '''
    time_boot_ms : int
    min_distance : int
    max_distance : int
    current_distance : int
    type : MAV_DISTANCE_SENSOR
    id : int
    orientation : MAV_SENSOR_ORIENTATION
    covariance : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IHHHBBBB', data, offset)
        return cls(*args)


@register('TERRAIN_REQUEST', 133)
@dataclass
class TerrainRequest(Unpackable):
    '''
    Request for terrain data and terrain status. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
    '''
    mask : int
    lat : int
    lon : int
    grid_spacing : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<iiHQ', data, offset)
        return cls(*args)


@register('TERRAIN_DATA', 134)
@dataclass
class TerrainData(Unpackable):
    '''
    Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
    '''
    lat : int
    lon : int
    grid_spacing : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    gridbit : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<iiHB32s', data, offset)
        args[4] = tuple(*struct.unpack('<16h', args[4]))
        return cls(*args)


@register('TERRAIN_CHECK', 135)
@dataclass
class TerrainCheck(Unpackable):
    '''
    Request that the vehicle report terrain height at the given location (expected response is a TERRAIN_REPORT). Used by GCS to check if vehicle has all terrain data needed for a mission.
    '''
    lat : int
    lon : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<ii', data, offset)
        return cls(*args)


@register('TERRAIN_REPORT', 136)
@dataclass
class TerrainReport(Unpackable):
    '''
    Streamed from drone to report progress of terrain map download (initiated by TERRAIN_REQUEST), or sent as a response to a TERRAIN_CHECK request. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
    '''
    lat : int
    lon : int
    terrain_height : float
    current_height : float
    spacing : int
    pending : int
    loaded : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<iiHffHH', data, offset)
        return cls(*args)


@register('SCALED_PRESSURE2', 137)
@dataclass
class ScaledPressure2(Unpackable):
    '''
    Barometer readings for 2nd barometer
    '''
    time_boot_ms : int
    press_abs : float
    press_diff : float
    temperature : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Iffh', data, offset)
        return cls(*args)


@register('ATT_POS_MOCAP', 138)
@dataclass
class AttPosMocap(Unpackable):
    '''
    Motion capture attitude and position
    '''
    time_usec : int
    q : Tuple[float,float,float,float]
    x : float
    y : float
    z : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Q16sfff', data, offset)
        args[1] = tuple(*struct.unpack('<4f', args[1]))
        return cls(*args)


@register('SET_ACTUATOR_CONTROL_TARGET', 139)
@dataclass
class SetActuatorControlTarget(Unpackable):
    '''
    Set the vehicle attitude and body angular rates.
    '''
    time_usec : int
    controls : Tuple[float,float,float,float,float,float,float,float]
    group_mlx : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBBB32s', data, offset)
        args[4] = tuple(*struct.unpack('<8f', args[4]))
        return cls(*args)


@register('ACTUATOR_CONTROL_TARGET', 140)
@dataclass
class ActuatorControlTarget(Unpackable):
    '''
    Set the vehicle attitude and body angular rates.
    '''
    time_usec : int
    controls : Tuple[float,float,float,float,float,float,float,float]
    group_mlx : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QB32s', data, offset)
        args[2] = tuple(*struct.unpack('<8f', args[2]))
        return cls(*args)


@register('ALTITUDE', 141)
@dataclass
class Altitude(Unpackable):
    '''
    The current system altitude.
    '''
    time_usec : int
    altitude_monotonic : float
    altitude_amsl : float
    altitude_local : float
    altitude_relative : float
    altitude_terrain : float
    bottom_clearance : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qffffff', data, offset)
        return cls(*args)


@register('RESOURCE_REQUEST', 142)
@dataclass
class ResourceRequest(Unpackable):
    '''
    The autopilot is requesting a resource (file, binary, other type of data)
    '''
    request_id : int
    uri_type : int
    uri : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    transfer_type : int
    storage : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB120sB120s', data, offset)
        args[2] = tuple(*struct.unpack('<120B', args[2]))
        args[4] = tuple(*struct.unpack('<120B', args[4]))
        return cls(*args)


@register('SCALED_PRESSURE3', 143)
@dataclass
class ScaledPressure3(Unpackable):
    '''
    Barometer readings for 3rd barometer
    '''
    time_boot_ms : int
    press_abs : float
    press_diff : float
    temperature : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Iffh', data, offset)
        return cls(*args)


@register('FOLLOW_TARGET', 144)
@dataclass
class FollowTarget(Unpackable):
    '''
    Current motion information from a designated system
    '''
    timestamp : int
    custom_state : int
    lat : int
    lon : int
    alt : float
    vel : Tuple[float,float,float]
    acc : Tuple[float,float,float]
    attitude_q : Tuple[float,float,float,float]
    rates : Tuple[float,float,float]
    position_cov : Tuple[float,float,float]
    est_capabilities : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBiif12s12s16s12s12sQ', data, offset)
        args[5] = tuple(*struct.unpack('<3f', args[5]))
        args[6] = tuple(*struct.unpack('<3f', args[6]))
        args[7] = tuple(*struct.unpack('<4f', args[7]))
        args[8] = tuple(*struct.unpack('<3f', args[8]))
        args[9] = tuple(*struct.unpack('<3f', args[9]))
        return cls(*args)


@register('CONTROL_SYSTEM_STATE', 146)
@dataclass
class ControlSystemState(Unpackable):
    '''
    The smoothed, monotonic system state used to feed the control loops of the system.
    '''
    time_usec : int
    x_acc : float
    y_acc : float
    z_acc : float
    x_vel : float
    y_vel : float
    z_vel : float
    x_pos : float
    y_pos : float
    z_pos : float
    airspeed : float
    vel_variance : Tuple[float,float,float]
    pos_variance : Tuple[float,float,float]
    q : Tuple[float,float,float,float]
    roll_rate : float
    pitch_rate : float
    yaw_rate : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qffffffffff12s12s16sfff', data, offset)
        args[11] = tuple(*struct.unpack('<3f', args[11]))
        args[12] = tuple(*struct.unpack('<3f', args[12]))
        args[13] = tuple(*struct.unpack('<4f', args[13]))
        return cls(*args)


@register('BATTERY_STATUS', 147)
@dataclass
class BatteryStatus(Unpackable):
    '''
    Battery information. Updates GCS with flight controller battery status. Smart batteries also use this message, but may additionally send BATTERY_INFO.
    '''
    current_consumed : int
    energy_consumed : int
    temperature : int
    voltages : Tuple[int,int,int,int,int,int,int,int,int,int]
    current_battery : int
    id : int
    battery_function : MAV_BATTERY_FUNCTION
    type : MAV_BATTERY_TYPE
    battery_remaining : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBh20shiib', data, offset)
        args[4] = tuple(*struct.unpack('<10H', args[4]))
        return cls(*args)


@register('AUTOPILOT_VERSION', 148)
@dataclass
class AutopilotVersion(Unpackable):
    '''
    Version and capability of autopilot software. This should be emitted in response to a request with MAV_CMD_REQUEST_MESSAGE.
    '''
    capabilities : MAV_PROTOCOL_CAPABILITY
    uid : int
    flight_sw_version : int
    middleware_sw_version : int
    os_sw_version : int
    board_version : int
    vendor_id : int
    product_id : int
    flight_custom_version : Tuple[int,int,int,int,int,int,int,int]
    middleware_custom_version : Tuple[int,int,int,int,int,int,int,int]
    os_custom_version : Tuple[int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QIIII8s8s8sHHQ', data, offset)
        args[5] = tuple(*struct.unpack('<8B', args[5]))
        args[6] = tuple(*struct.unpack('<8B', args[6]))
        args[7] = tuple(*struct.unpack('<8B', args[7]))
        return cls(*args)


@register('LANDING_TARGET', 149)
@dataclass
class LandingTarget(Unpackable):
    '''
    The location of a landing target. See: https://mavlink.io/en/services/landing_target.html
    '''
    time_usec : int
    angle_x : float
    angle_y : float
    distance : float
    size_x : float
    size_y : float
    target_num : int
    frame : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBBfffff', data, offset)
        return cls(*args)


@register('FENCE_STATUS', 162)
@dataclass
class FenceStatus(Unpackable):
    '''
    Status of geo-fencing. Sent in extended status stream when fencing enabled.
    '''
    breach_time : int
    breach_count : int
    breach_status : int
    breach_type : FENCE_BREACH

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BHBI', data, offset)
        return cls(*args)


@register('MAG_CAL_REPORT', 192)
@dataclass
class MagCalReport(Unpackable):
    '''
    Reports results of completed compass calibration. Sent until MAG_CAL_ACK received.
    '''
    fitness : float
    ofs_x : float
    ofs_y : float
    ofs_z : float
    diag_x : float
    diag_y : float
    diag_z : float
    offdiag_x : float
    offdiag_y : float
    offdiag_z : float
    compass_id : int
    cal_mask : int
    cal_status : MAG_CAL_STATUS
    autosaved : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBBffffffffff', data, offset)
        return cls(*args)


@register('EFI_STATUS', 225)
@dataclass
class EfiStatus(Unpackable):
    '''
    EFI status output
    '''
    ecu_index : float
    rpm : float
    fuel_consumed : float
    fuel_flow : float
    engine_load : float
    throttle_position : float
    spark_dwell_time : float
    barometric_pressure : float
    intake_manifold_pressure : float
    intake_manifold_temperature : float
    cylinder_head_temperature : float
    ignition_timing : float
    injection_time : float
    exhaust_gas_temperature : float
    throttle_out : float
    pt_compensation : float
    health : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Bffffffffffffffff', data, offset)
        return cls(*args)


@register('ESTIMATOR_STATUS', 230)
@dataclass
class EstimatorStatus(Unpackable):
    '''
    Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS enum definition for further information. The innovation test ratios show the magnitude of the sensor innovation divided by the innovation check threshold. Under normal operation the innovation test ratios should be below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should be optional and controllable by the user.
    '''
    time_usec : int
    vel_ratio : float
    pos_horiz_ratio : float
    pos_vert_ratio : float
    mag_ratio : float
    hagl_ratio : float
    tas_ratio : float
    pos_horiz_accuracy : float
    pos_vert_accuracy : float
    flags : ESTIMATOR_STATUS_FLAGS

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QHffffffff', data, offset)
        return cls(*args)


@register('WIND_COV', 231)
@dataclass
class WindCov(Unpackable):
    '''
    Wind estimate from vehicle. Note that despite the name, this message does not actually contain any covariances but instead variability and accuracy fields in terms of standard deviation (1-STD).
    '''
    time_usec : int
    wind_x : float
    wind_y : float
    wind_z : float
    var_horiz : float
    var_vert : float
    wind_alt : float
    horiz_accuracy : float
    vert_accuracy : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Qffffffff', data, offset)
        return cls(*args)


@register('GPS_INPUT', 232)
@dataclass
class GpsInput(Unpackable):
    '''
    GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position estimate of the system.
    '''
    time_usec : int
    time_week_ms : int
    lat : int
    lon : int
    alt : float
    hdop : float
    vdop : float
    vn : float
    ve : float
    vd : float
    speed_accuracy : float
    horiz_accuracy : float
    vert_accuracy : float
    ignore_flags : GPS_INPUT_IGNORE_FLAGS
    time_week : int
    gps_id : int
    fix_type : int
    satellites_visible : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBHIHBiifffffffffB', data, offset)
        return cls(*args)


@register('GPS_RTCM_DATA', 233)
@dataclass
class GpsRtcmData(Unpackable):
    '''
    RTCM message for injecting into the onboard GPS (used for DGPS)
    '''
    flags : int
    len : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB180s', data, offset)
        args[2] = tuple(*struct.unpack('<180B', args[2]))
        return cls(*args)


@register('HIGH_LATENCY', 234)
@dataclass
class HighLatency(Unpackable):
    '''
    Message appropriate for high latency connections like Iridium
    '''
    custom_mode : int
    latitude : int
    longitude : int
    roll : int
    pitch : int
    heading : int
    heading_sp : int
    altitude_amsl : int
    altitude_sp : int
    wp_distance : int
    base_mode : MAV_MODE_FLAG
    landed_state : MAV_LANDED_STATE
    throttle : int
    airspeed : int
    airspeed_sp : int
    groundspeed : int
    climb_rate : int
    gps_nsat : int
    gps_fix_type : GPS_FIX_TYPE
    battery_remaining : int
    temperature : int
    temperature_air : int
    failsafe : int
    wp_num : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BIBhhHbhiihhBBBbBBBbbBBH', data, offset)
        return cls(*args)


@register('HIGH_LATENCY2', 235)
@dataclass
class HighLatency2(Unpackable):
    '''
    Message appropriate for high latency connections like Iridium (version 2)
    '''
    timestamp : int
    latitude : int
    longitude : int
    custom_mode : int
    altitude : int
    target_altitude : int
    target_distance : int
    wp_num : int
    failure_flags : HL_FAILURE_FLAG
    type : MAV_TYPE
    autopilot : MAV_AUTOPILOT
    heading : int
    target_heading : int
    throttle : int
    airspeed : int
    airspeed_sp : int
    groundspeed : int
    windspeed : int
    wind_heading : int
    eph : int
    epv : int
    temperature_air : int
    climb_rate : int
    battery : int
    custom0 : int
    custom1 : int
    custom2 : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBBHiihhBBHBBBBBBBBbbbHHbbb', data, offset)
        return cls(*args)


@register('VIBRATION', 241)
@dataclass
class Vibration(Unpackable):
    '''
    Vibration levels and accelerometer clipping
    '''
    time_usec : int
    vibration_x : float
    vibration_y : float
    vibration_z : float
    clipping_0 : int
    clipping_1 : int
    clipping_2 : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QfffIII', data, offset)
        return cls(*args)


@register('HOME_POSITION', 242)
@dataclass
class HomePosition(Unpackable):
    '''
    Contains the home position.
	The home position is the default position that the system will return to and land on.
	The position must be set automatically by the system during the takeoff, and may also be explicitly set using MAV_CMD_DO_SET_HOME.
	The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface.
	Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach.
	The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
        Note: this message can be requested by sending the MAV_CMD_REQUEST_MESSAGE with param1=242 (or the deprecated MAV_CMD_GET_HOME_POSITION command).
    '''
    latitude : int
    longitude : int
    altitude : int
    x : float
    y : float
    z : float
    q : Tuple[float,float,float,float]
    approach_x : float
    approach_y : float
    approach_z : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<iiifff16sfff', data, offset)
        args[6] = tuple(*struct.unpack('<4f', args[6]))
        return cls(*args)


@register('SET_HOME_POSITION', 243)
@dataclass
class SetHomePosition(Unpackable):
    '''
    Sets the home position.
	The home position is the default position that the system will return to and land on.
        The position is set automatically by the system during the takeoff (and may also be set using this message).
        The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface.
        Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach.
        The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
        Note: the current home position may be emitted in a HOME_POSITION message on request (using MAV_CMD_REQUEST_MESSAGE with param1=242).
    '''
    latitude : int
    longitude : int
    altitude : int
    x : float
    y : float
    z : float
    q : Tuple[float,float,float,float]
    approach_x : float
    approach_y : float
    approach_z : float
    target_system : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Biiifff16sfff', data, offset)
        args[7] = tuple(*struct.unpack('<4f', args[7]))
        return cls(*args)


@register('MESSAGE_INTERVAL', 244)
@dataclass
class MessageInterval(Unpackable):
    '''
    The interval between messages for a particular MAVLink message ID.
        This message is sent in response to the MAV_CMD_REQUEST_MESSAGE command with param1=244 (this message) and param2=message_id (the id of the message for which the interval is required).
	It may also be sent in response to MAV_CMD_GET_MESSAGE_INTERVAL.
	This interface replaces DATA_STREAM.
    '''
    interval_us : int
    message_id : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Hi', data, offset)
        return cls(*args)


@register('EXTENDED_SYS_STATE', 245)
@dataclass
class ExtendedSysState(Unpackable):
    '''
    Provides state for additional features
    '''
    vtol_state : MAV_VTOL_STATE
    landed_state : MAV_LANDED_STATE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB', data, offset)
        return cls(*args)


@register('ADSB_VEHICLE', 246)
@dataclass
class AdsbVehicle(Unpackable):
    '''
    The location and information of an ADSB vehicle
    '''
    ICAO_address : int
    lat : int
    lon : int
    altitude : int
    heading : int
    hor_velocity : int
    ver_velocity : int
    flags : ADSB_FLAGS
    squawk : int
    altitude_type : ADSB_ALTITUDE_TYPE
    callsign : bytes
    emitter_type : ADSB_EMITTER_TYPE
    tslc : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IiiBiHHh9sBBHH', data, offset)
        return cls(*args)


@register('COLLISION', 247)
@dataclass
class Collision(Unpackable):
    '''
    Information about a potential collision
    '''
    id : int
    time_to_minimum_delta : float
    altitude_minimum_delta : float
    horizontal_minimum_delta : float
    src : MAV_COLLISION_SRC
    action : MAV_COLLISION_ACTION
    threat_level : MAV_COLLISION_THREAT_LEVEL

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BIBBfff', data, offset)
        return cls(*args)


@register('V2_EXTENSION', 248)
@dataclass
class V2Extension(Unpackable):
    '''
    Message implementing parts of the V2 payload specs in V1 frames for transitional support.
    '''
    message_type : int
    target_network : int
    target_system : int
    target_component : int
    payload : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBH249s', data, offset)
        args[4] = tuple(*struct.unpack('<249B', args[4]))
        return cls(*args)


@register('MEMORY_VECT', 249)
@dataclass
class MemoryVect(Unpackable):
    '''
    Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    '''
    address : int
    ver : int
    type : int
    value : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<HBB32s', data, offset)
        args[3] = tuple(*struct.unpack('<32b', args[3]))
        return cls(*args)


@register('DEBUG_VECT', 250)
@dataclass
class DebugVect(Unpackable):
    '''
    To debug something using a named 3D vector.
    '''
    time_usec : int
    x : float
    y : float
    z : float
    name : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<10sQfff', data, offset)
        return cls(*args)


@register('NAMED_VALUE_FLOAT', 251)
@dataclass
class NamedValueFloat(Unpackable):
    '''
    Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    '''
    time_boot_ms : int
    value : float
    name : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<I10sf', data, offset)
        return cls(*args)


@register('NAMED_VALUE_INT', 252)
@dataclass
class NamedValueInt(Unpackable):
    '''
    Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    '''
    time_boot_ms : int
    value : int
    name : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<I10si', data, offset)
        return cls(*args)


@register('STATUSTEXT', 253)
@dataclass
class Statustext(Unpackable):
    '''
    Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz).
    '''
    severity : MAV_SEVERITY
    text : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<B50s', data, offset)
        return cls(*args)


@register('DEBUG', 254)
@dataclass
class Debug(Unpackable):
    '''
    Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N.
    '''
    time_boot_ms : int
    value : float
    ind : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBf', data, offset)
        return cls(*args)


@register('SETUP_SIGNING', 256)
@dataclass
class SetupSigning(Unpackable):
    '''
    Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable signing
    '''
    initial_timestamp : int
    target_system : int
    target_component : int
    secret_key : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB32sQ', data, offset)
        args[2] = tuple(*struct.unpack('<32B', args[2]))
        return cls(*args)


@register('BUTTON_CHANGE', 257)
@dataclass
class ButtonChange(Unpackable):
    '''
    Report button state change.
    '''
    time_boot_ms : int
    last_change_ms : int
    state : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IIB', data, offset)
        return cls(*args)


@register('PLAY_TUNE', 258)
@dataclass
class PlayTune(Unpackable):
    '''
    Control vehicle tone generation (buzzer).
    '''
    target_system : int
    target_component : int
    tune : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB30s', data, offset)
        return cls(*args)


@register('CAMERA_INFORMATION', 259)
@dataclass
class CameraInformation(Unpackable):
    '''
    Information about a camera. Can be requested with a MAV_CMD_REQUEST_MESSAGE command.
    '''
    time_boot_ms : int
    firmware_version : int
    focal_length : float
    sensor_size_h : float
    sensor_size_v : float
    flags : CAMERA_CAP_FLAGS
    resolution_h : int
    resolution_v : int
    cam_definition_version : int
    vendor_name : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    model_name : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    lens_id : int
    cam_definition_uri : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<I32s32sIfffHHBIH140s', data, offset)
        args[1] = tuple(*struct.unpack('<32B', args[1]))
        args[2] = tuple(*struct.unpack('<32B', args[2]))
        return cls(*args)


@register('CAMERA_SETTINGS', 260)
@dataclass
class CameraSettings(Unpackable):
    '''
    Settings of a camera. Can be requested with a MAV_CMD_REQUEST_MESSAGE command.
    '''
    time_boot_ms : int
    mode_id : CAMERA_MODE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IB', data, offset)
        return cls(*args)


@register('STORAGE_INFORMATION', 261)
@dataclass
class StorageInformation(Unpackable):
    '''
    Information about a storage medium. This message is sent in response to a request with MAV_CMD_REQUEST_MESSAGE and whenever the status of the storage changes (STORAGE_STATUS). Use MAV_CMD_REQUEST_MESSAGE.param2 to indicate the index/id of requested storage: 0 for all, 1 for first, 2 for second, etc.
    '''
    time_boot_ms : int
    total_capacity : float
    used_capacity : float
    available_capacity : float
    read_speed : float
    write_speed : float
    storage_id : int
    storage_count : int
    status : STORAGE_STATUS

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBBBfffff', data, offset)
        return cls(*args)


@register('CAMERA_CAPTURE_STATUS', 262)
@dataclass
class CameraCaptureStatus(Unpackable):
    '''
    Information about the status of a capture. Can be requested with a MAV_CMD_REQUEST_MESSAGE command.
    '''
    time_boot_ms : int
    image_interval : float
    recording_time_ms : int
    available_capacity : float
    image_status : int
    video_status : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBBfIf', data, offset)
        return cls(*args)


@register('CAMERA_IMAGE_CAPTURED', 263)
@dataclass
class CameraImageCaptured(Unpackable):
    '''
    Information about a captured image. This is emitted every time a message is captured.
        MAV_CMD_REQUEST_MESSAGE can be used to (re)request this message for a specific sequence number or range of sequence numbers:
        MAV_CMD_REQUEST_MESSAGE.param2 indicates the sequence number the first image to send, or set to -1 to send the message for all sequence numbers.
        MAV_CMD_REQUEST_MESSAGE.param3 is used to specify a range of messages to send:
        set to 0 (default) to send just the the message for the sequence number in param 2,
        set to -1 to send the message for the sequence number in param 2 and all the following sequence numbers,
        set to the sequence number of the final message in the range.
    '''
    time_utc : int
    time_boot_ms : int
    lat : int
    lon : int
    alt : int
    relative_alt : int
    q : Tuple[float,float,float,float]
    image_index : int
    camera_id : int
    capture_result : int
    file_url : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IQBiiii16sib205s', data, offset)
        args[7] = tuple(*struct.unpack('<4f', args[7]))
        return cls(*args)


@register('FLIGHT_INFORMATION', 264)
@dataclass
class FlightInformation(Unpackable):
    '''
    Flight information.
        This includes time since boot for arm, takeoff, and land, and a flight number.
        Takeoff and landing values reset to zero on arm.
        This can be requested using MAV_CMD_REQUEST_MESSAGE.
        Note, some fields are misnamed - timestamps are from boot (not UTC) and the flight_uuid is a sequence number.
    '''
    arming_time_utc : int
    takeoff_time_utc : int
    flight_uuid : int
    time_boot_ms : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IQQQ', data, offset)
        return cls(*args)


@register('MOUNT_ORIENTATION', 265)
@dataclass
class MountOrientation(Unpackable):
    '''
    Orientation of a mount
    '''
    time_boot_ms : int
    roll : float
    pitch : float
    yaw : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Ifff', data, offset)
        return cls(*args)


@register('LOGGING_DATA', 266)
@dataclass
class LoggingData(Unpackable):
    '''
    A message containing logged data (see also MAV_CMD_LOGGING_START)
    '''
    sequence : int
    target_system : int
    target_component : int
    length : int
    first_message_offset : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHBB249s', data, offset)
        args[5] = tuple(*struct.unpack('<249B', args[5]))
        return cls(*args)


@register('LOGGING_DATA_ACKED', 267)
@dataclass
class LoggingDataAcked(Unpackable):
    '''
    A message containing logged data which requires a LOGGING_ACK to be sent back
    '''
    sequence : int
    target_system : int
    target_component : int
    length : int
    first_message_offset : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHBB249s', data, offset)
        args[5] = tuple(*struct.unpack('<249B', args[5]))
        return cls(*args)


@register('LOGGING_ACK', 268)
@dataclass
class LoggingAck(Unpackable):
    '''
    An ack for a LOGGING_DATA_ACKED message
    '''
    sequence : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBH', data, offset)
        return cls(*args)


@register('VIDEO_STREAM_INFORMATION', 269)
@dataclass
class VideoStreamInformation(Unpackable):
    '''
    Information about video stream. It may be requested using MAV_CMD_REQUEST_MESSAGE, where param2 indicates the video stream id: 0 for all streams, 1 for first, 2 for second, etc.
    '''
    framerate : float
    bitrate : int
    flags : VIDEO_STREAM_STATUS_FLAGS
    resolution_h : int
    resolution_v : int
    rotation : int
    hfov : int
    stream_id : int
    count : int
    type : VIDEO_STREAM_TYPE
    name : bytes
    uri : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBHfHHIHH32s160s', data, offset)
        return cls(*args)


@register('VIDEO_STREAM_STATUS', 270)
@dataclass
class VideoStreamStatus(Unpackable):
    '''
    Information about the status of a video stream. It may be requested using MAV_CMD_REQUEST_MESSAGE.
    '''
    framerate : float
    bitrate : int
    flags : VIDEO_STREAM_STATUS_FLAGS
    resolution_h : int
    resolution_v : int
    rotation : int
    hfov : int
    stream_id : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BHfHHIHH', data, offset)
        return cls(*args)


@register('CAMERA_FOV_STATUS', 271)
@dataclass
class CameraFovStatus(Unpackable):
    '''
    Information about the field of view of a camera. Can be requested with a MAV_CMD_REQUEST_MESSAGE command.
    '''
    time_boot_ms : int
    lat_camera : int
    lon_camera : int
    alt_camera : int
    lat_image : int
    lon_image : int
    alt_image : int
    q : Tuple[float,float,float,float]
    hfov : float
    vfov : float

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Iiiiiii16sff', data, offset)
        args[7] = tuple(*struct.unpack('<4f', args[7]))
        return cls(*args)


@register('CAMERA_TRACKING_IMAGE_STATUS', 275)
@dataclass
class CameraTrackingImageStatus(Unpackable):
    '''
    Camera tracking status, sent while in active tracking. Use MAV_CMD_SET_MESSAGE_INTERVAL to define message interval.
    '''
    point_x : float
    point_y : float
    radius : float
    rec_top_x : float
    rec_top_y : float
    rec_bottom_x : float
    rec_bottom_y : float
    tracking_status : CAMERA_TRACKING_STATUS_FLAGS
    tracking_mode : CAMERA_TRACKING_MODE
    target_data : CAMERA_TRACKING_TARGET_DATA

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBfffffff', data, offset)
        return cls(*args)


@register('CAMERA_TRACKING_GEO_STATUS', 276)
@dataclass
class CameraTrackingGeoStatus(Unpackable):
    '''
    Camera tracking status, sent while in active tracking. Use MAV_CMD_SET_MESSAGE_INTERVAL to define message interval.
    '''
    lat : int
    lon : int
    alt : float
    h_acc : float
    v_acc : float
    vel_n : float
    vel_e : float
    vel_d : float
    vel_acc : float
    dist : float
    hdg : float
    hdg_acc : float
    tracking_status : CAMERA_TRACKING_STATUS_FLAGS

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Biiffffffffff', data, offset)
        return cls(*args)


@register('CAMERA_THERMAL_RANGE', 277)
@dataclass
class CameraThermalRange(Unpackable):
    '''
    Camera absolute thermal range. This can be streamed when the associated VIDEO_STREAM_STATUS `flag` field bit VIDEO_STREAM_STATUS_FLAGS_THERMAL_RANGE_ENABLED is set, but a GCS may choose to only request it for the current active stream. Use MAV_CMD_SET_MESSAGE_INTERVAL to define message interval (param3 indicates the stream id of the current camera, or 0 for all streams, param4 indicates the target camera_device_id for autopilot-attached cameras or 0 for MAVLink cameras).
    '''
    time_boot_ms : int
    max : float
    max_point_x : float
    max_point_y : float
    min : float
    min_point_x : float
    min_point_y : float
    stream_id : int
    camera_device_id : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBBffffff', data, offset)
        return cls(*args)


@register('GIMBAL_MANAGER_INFORMATION', 280)
@dataclass
class GimbalManagerInformation(Unpackable):
    '''
    Information about a high level gimbal manager. This message should be requested by a ground station using MAV_CMD_REQUEST_MESSAGE.
    '''
    time_boot_ms : int
    cap_flags : GIMBAL_MANAGER_CAP_FLAGS
    roll_min : float
    roll_max : float
    pitch_min : float
    pitch_max : float
    yaw_min : float
    yaw_max : float
    gimbal_device_id : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IIBffffff', data, offset)
        return cls(*args)


@register('GIMBAL_MANAGER_STATUS', 281)
@dataclass
class GimbalManagerStatus(Unpackable):
    '''
    Current status about a high level gimbal manager. This message should be broadcast at a low regular rate (e.g. 5Hz).
    '''
    time_boot_ms : int
    flags : GIMBAL_MANAGER_FLAGS
    gimbal_device_id : int
    primary_control_sysid : int
    primary_control_compid : int
    secondary_control_sysid : int
    secondary_control_compid : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IIBBBBB', data, offset)
        return cls(*args)


@register('GIMBAL_MANAGER_SET_ATTITUDE', 282)
@dataclass
class GimbalManagerSetAttitude(Unpackable):
    '''
    High level message to control a gimbal's attitude. This message is to be sent to the gimbal manager (e.g. from a ground station). Angles and rates can be set to NaN according to use case.
    '''
    flags : GIMBAL_MANAGER_FLAGS
    q : Tuple[float,float,float,float]
    angular_velocity_x : float
    angular_velocity_y : float
    angular_velocity_z : float
    target_system : int
    target_component : int
    gimbal_device_id : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBIB16sfff', data, offset)
        args[4] = tuple(*struct.unpack('<4f', args[4]))
        return cls(*args)


@register('GIMBAL_DEVICE_INFORMATION', 283)
@dataclass
class GimbalDeviceInformation(Unpackable):
    '''
    Information about a low level gimbal. This message should be requested by the gimbal manager or a ground station using MAV_CMD_REQUEST_MESSAGE. The maximum angles and rates are the limits by hardware. However, the limits by software used are likely different/smaller and dependent on mode/settings/etc..
    '''
    uid : int
    time_boot_ms : int
    firmware_version : int
    hardware_version : int
    roll_min : float
    roll_max : float
    pitch_min : float
    pitch_max : float
    yaw_min : float
    yaw_max : float
    cap_flags : GIMBAL_DEVICE_CAP_FLAGS
    custom_cap_flags : int
    vendor_name : bytes
    model_name : bytes
    custom_name : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<I32s32s32sIIQHHffffff', data, offset)
        return cls(*args)


@register('GIMBAL_DEVICE_SET_ATTITUDE', 284)
@dataclass
class GimbalDeviceSetAttitude(Unpackable):
    '''
    Low level message to control a gimbal device's attitude.
	  This message is to be sent from the gimbal manager to the gimbal device component.
	  The quaternion and angular velocities can be set to NaN according to use case.
	  For the angles encoded in the quaternion and the angular velocities holds:
	  If the flag GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME is set, then they are relative to the vehicle heading (vehicle frame).
	  If the flag GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME is set, then they are relative to absolute North (earth frame).
	  If neither of these flags are set, then (for backwards compatibility) it holds:
	  If the flag GIMBAL_DEVICE_FLAGS_YAW_LOCK is set, then they are relative to absolute North (earth frame),
	  else they are relative to the vehicle heading (vehicle frame).
	  Setting both GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME and GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME is not allowed.
	  These rules are to ensure backwards compatibility.
	  New implementations should always set either GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME or GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME.
    '''
    q : Tuple[float,float,float,float]
    angular_velocity_x : float
    angular_velocity_y : float
    angular_velocity_z : float
    flags : GIMBAL_DEVICE_FLAGS
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBH16sfff', data, offset)
        args[3] = tuple(*struct.unpack('<4f', args[3]))
        return cls(*args)


@register('GIMBAL_DEVICE_ATTITUDE_STATUS', 285)
@dataclass
class GimbalDeviceAttitudeStatus(Unpackable):
    '''
    Message reporting the status of a gimbal device.
	  This message should be broadcast by a gimbal device component at a low regular rate (e.g. 5 Hz).
	  For the angles encoded in the quaternion and the angular velocities holds:
	  If the flag GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME is set, then they are relative to the vehicle heading (vehicle frame).
	  If the flag GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME is set, then they are relative to absolute North (earth frame).
	  If neither of these flags are set, then (for backwards compatibility) it holds:
	  If the flag GIMBAL_DEVICE_FLAGS_YAW_LOCK is set, then they are relative to absolute North (earth frame),
	  else they are relative to the vehicle heading (vehicle frame).
	  Other conditions of the flags are not allowed.
	  The quaternion and angular velocities in the other frame can be calculated from delta_yaw and delta_yaw_velocity as
	  q_earth = q_delta_yaw * q_vehicle and w_earth = w_delta_yaw_velocity + w_vehicle (if not NaN).
	  If neither the GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME nor the GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME flag is set,
	  then (for backwards compatibility) the data in the delta_yaw and delta_yaw_velocity fields are to be ignored.
	  New implementations should always set either GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME or GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME,
	  and always should set delta_yaw and delta_yaw_velocity either to the proper value or NaN.
    '''
    time_boot_ms : int
    q : Tuple[float,float,float,float]
    angular_velocity_x : float
    angular_velocity_y : float
    angular_velocity_z : float
    failure_flags : GIMBAL_DEVICE_ERROR_FLAGS
    flags : GIMBAL_DEVICE_FLAGS
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBIH16sfffI', data, offset)
        args[4] = tuple(*struct.unpack('<4f', args[4]))
        return cls(*args)


@register('AUTOPILOT_STATE_FOR_GIMBAL_DEVICE', 286)
@dataclass
class AutopilotStateForGimbalDevice(Unpackable):
    '''
    Low level message containing autopilot state relevant for a gimbal device. This message is to be sent from the autopilot to the gimbal device component. The data of this message are for the gimbal device's estimator corrections, in particular horizon compensation, as well as indicates autopilot control intentions, e.g. feed forward angular control in the z-axis.
    '''
    time_boot_us : int
    q : Tuple[float,float,float,float]
    q_estimated_delay_us : int
    vx : float
    vy : float
    vz : float
    v_estimated_delay_us : int
    feed_forward_angular_velocity_z : float
    estimator_status : ESTIMATOR_STATUS_FLAGS
    target_system : int
    target_component : int
    landed_state : MAV_LANDED_STATE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBQ16sIfffIfHB', data, offset)
        args[3] = tuple(*struct.unpack('<4f', args[3]))
        return cls(*args)


@register('GIMBAL_MANAGER_SET_PITCHYAW', 287)
@dataclass
class GimbalManagerSetPitchyaw(Unpackable):
    '''
    Set gimbal manager pitch and yaw angles (high rate message). This message is to be sent to the gimbal manager (e.g. from a ground station) and will be ignored by gimbal devices. Angles and rates can be set to NaN according to use case. Use MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW for low-rate adjustments that require confirmation.
    '''
    flags : GIMBAL_MANAGER_FLAGS
    pitch : float
    yaw : float
    pitch_rate : float
    yaw_rate : float
    target_system : int
    target_component : int
    gimbal_device_id : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBIBffff', data, offset)
        return cls(*args)


@register('GIMBAL_MANAGER_SET_MANUAL_CONTROL', 288)
@dataclass
class GimbalManagerSetManualControl(Unpackable):
    '''
    High level message to control a gimbal manually. The angles or angular rates are unitless; the actual rates will depend on internal gimbal manager settings/configuration (e.g. set by parameters). This message is to be sent to the gimbal manager (e.g. from a ground station). Angles and rates can be set to NaN according to use case.
    '''
    flags : GIMBAL_MANAGER_FLAGS
    pitch : float
    yaw : float
    pitch_rate : float
    yaw_rate : float
    target_system : int
    target_component : int
    gimbal_device_id : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBIBffff', data, offset)
        return cls(*args)


@register('ESC_INFO', 290)
@dataclass
class EscInfo(Unpackable):
    '''
    ESC information for lower rate streaming. Recommended streaming rate 1Hz. See ESC_STATUS for higher-rate ESC data.
    '''
    time_usec : int
    error_count : Tuple[int,int,int,int]
    counter : int
    failure_flags : ESC_FAILURE_FLAGS
    temperature : Tuple[int,int,int,int]
    index : int
    count : int
    connection_type : ESC_CONNECTION_TYPE
    info : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BQHBBB8s16s8s', data, offset)
        args[6] = tuple(*struct.unpack('<4H', args[6]))
        args[7] = tuple(*struct.unpack('<4I', args[7]))
        args[8] = tuple(*struct.unpack('<4h', args[8]))
        return cls(*args)


@register('ESC_STATUS', 291)
@dataclass
class EscStatus(Unpackable):
    '''
    ESC information for higher rate streaming. Recommended streaming rate is ~10 Hz. Information that changes more slowly is sent in ESC_INFO. It should typically only be streamed on high-bandwidth links (i.e. to a companion computer).
    '''
    time_usec : int
    rpm : Tuple[int,int,int,int]
    voltage : Tuple[float,float,float,float]
    current : Tuple[float,float,float,float]
    index : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BQ16s16s16s', data, offset)
        args[2] = tuple(*struct.unpack('<4i', args[2]))
        args[3] = tuple(*struct.unpack('<4f', args[3]))
        args[4] = tuple(*struct.unpack('<4f', args[4]))
        return cls(*args)


@register('WIFI_CONFIG_AP', 299)
@dataclass
class WifiConfigAp(Unpackable):
    '''
    Configure WiFi AP SSID, password, and mode. This message is re-emitted as an acknowledgement by the AP. The message may also be explicitly requested using MAV_CMD_REQUEST_MESSAGE
    '''
    ssid : bytes
    password : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<32s64s', data, offset)
        return cls(*args)


@register('AIS_VESSEL', 301)
@dataclass
class AisVessel(Unpackable):
    '''
    The location and information of an AIS vessel
    '''
    MMSI : int
    lat : int
    lon : int
    COG : int
    heading : int
    velocity : int
    dimension_bow : int
    dimension_stern : int
    tslc : int
    flags : AIS_FLAGS
    turn_rate : int
    navigational_status : AIS_NAV_STATUS
    type : AIS_TYPE
    dimension_port : int
    dimension_starboard : int
    callsign : bytes
    name : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IiiHHHbBBHHBB7s20sHH', data, offset)
        return cls(*args)


@register('UAVCAN_NODE_STATUS', 310)
@dataclass
class UavcanNodeStatus(Unpackable):
    '''
    General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus" for the background information. The UAVCAN specification is available at http://uavcan.org.
    '''
    time_usec : int
    uptime_sec : int
    vendor_specific_status_code : int
    health : UAVCAN_NODE_HEALTH
    mode : UAVCAN_NODE_MODE
    sub_mode : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QIBBBH', data, offset)
        return cls(*args)


@register('UAVCAN_NODE_INFO', 311)
@dataclass
class UavcanNodeInfo(Unpackable):
    '''
    General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification is available at http://uavcan.org.
    '''
    time_usec : int
    uptime_sec : int
    sw_vcs_commit : int
    name : bytes
    hw_version_major : int
    hw_version_minor : int
    hw_unique_id : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    sw_version_major : int
    sw_version_minor : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QI80sBB16sBBI', data, offset)
        args[5] = tuple(*struct.unpack('<16B', args[5]))
        return cls(*args)


@register('PARAM_EXT_REQUEST_READ', 320)
@dataclass
class ParamExtRequestRead(Unpackable):
    '''
    Request to read the value of a parameter with either the param_id string id or param_index. PARAM_EXT_VALUE should be emitted in response.
    '''
    param_index : int
    target_system : int
    target_component : int
    param_id : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB16sh', data, offset)
        return cls(*args)


@register('PARAM_EXT_REQUEST_LIST', 321)
@dataclass
class ParamExtRequestList(Unpackable):
    '''
    Request all parameters of this component. All parameters should be emitted in response as PARAM_EXT_VALUE.
    '''
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB', data, offset)
        return cls(*args)


@register('PARAM_EXT_VALUE', 322)
@dataclass
class ParamExtValue(Unpackable):
    '''
    Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows them to re-request missing parameters after a loss or timeout.
    '''
    param_count : int
    param_index : int
    param_id : bytes
    param_value : bytes
    param_type : MAV_PARAM_EXT_TYPE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<16s128sBHH', data, offset)
        return cls(*args)


@register('PARAM_EXT_SET', 323)
@dataclass
class ParamExtSet(Unpackable):
    '''
    Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when setting a parameter value and the new value is the same as the current value, you will immediately get a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive a PARAM_ACK_IN_PROGRESS in response.
    '''
    target_system : int
    target_component : int
    param_id : bytes
    param_value : bytes
    param_type : MAV_PARAM_EXT_TYPE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB16s128sB', data, offset)
        return cls(*args)


@register('PARAM_EXT_ACK', 324)
@dataclass
class ParamExtAck(Unpackable):
    '''
    Response from a PARAM_EXT_SET message.
    '''
    param_id : bytes
    param_value : bytes
    param_type : MAV_PARAM_EXT_TYPE
    param_result : PARAM_ACK

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<16s128sBB', data, offset)
        return cls(*args)


@register('OBSTACLE_DISTANCE', 330)
@dataclass
class ObstacleDistance(Unpackable):
    '''
    Obstacle distances in front of the sensor, starting from the left in increment degrees to the right
    '''
    time_usec : int
    distances : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    min_distance : int
    max_distance : int
    sensor_type : MAV_DISTANCE_SENSOR
    increment : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QB144sBHH', data, offset)
        args[2] = tuple(*struct.unpack('<72H', args[2]))
        return cls(*args)


@register('ODOMETRY', 331)
@dataclass
class Odometry(Unpackable):
    '''
    Odometry message to communicate odometry information with an external interface. Fits ROS REP 147 standard for aerial vehicles (http://www.ros.org/reps/rep-0147.html).
    '''
    time_usec : int
    x : float
    y : float
    z : float
    q : Tuple[float,float,float,float]
    vx : float
    vy : float
    vz : float
    rollspeed : float
    pitchspeed : float
    yawspeed : float
    pose_covariance : Tuple[float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float]
    velocity_covariance : Tuple[float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float]
    frame_id : MAV_FRAME
    child_frame_id : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QBBfff16sffffff84s84s', data, offset)
        args[6] = tuple(*struct.unpack('<4f', args[6]))
        args[13] = tuple(*struct.unpack('<21f', args[13]))
        args[14] = tuple(*struct.unpack('<21f', args[14]))
        return cls(*args)


@register('TRAJECTORY_REPRESENTATION_WAYPOINTS', 332)
@dataclass
class TrajectoryRepresentationWaypoints(Unpackable):
    '''
    Describe a trajectory using an array of up-to 5 waypoints in the local frame (MAV_FRAME_LOCAL_NED).
    '''
    time_usec : int
    pos_x : Tuple[float,float,float,float,float]
    pos_y : Tuple[float,float,float,float,float]
    pos_z : Tuple[float,float,float,float,float]
    vel_x : Tuple[float,float,float,float,float]
    vel_y : Tuple[float,float,float,float,float]
    vel_z : Tuple[float,float,float,float,float]
    acc_x : Tuple[float,float,float,float,float]
    acc_y : Tuple[float,float,float,float,float]
    acc_z : Tuple[float,float,float,float,float]
    pos_yaw : Tuple[float,float,float,float,float]
    vel_yaw : Tuple[float,float,float,float,float]
    command : MAV_CMD
    valid_points : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QB20s20s20s20s20s20s20s20s20s20s20s10s', data, offset)
        args[2] = tuple(*struct.unpack('<5f', args[2]))
        args[3] = tuple(*struct.unpack('<5f', args[3]))
        args[4] = tuple(*struct.unpack('<5f', args[4]))
        args[5] = tuple(*struct.unpack('<5f', args[5]))
        args[6] = tuple(*struct.unpack('<5f', args[6]))
        args[7] = tuple(*struct.unpack('<5f', args[7]))
        args[8] = tuple(*struct.unpack('<5f', args[8]))
        args[9] = tuple(*struct.unpack('<5f', args[9]))
        args[10] = tuple(*struct.unpack('<5f', args[10]))
        args[11] = tuple(*struct.unpack('<5f', args[11]))
        args[12] = tuple(*struct.unpack('<5f', args[12]))
        args[13] = tuple(*struct.unpack('<5H', args[13]))
        return cls(*args)


@register('TRAJECTORY_REPRESENTATION_BEZIER', 333)
@dataclass
class TrajectoryRepresentationBezier(Unpackable):
    '''
    Describe a trajectory using an array of up-to 5 bezier control points in the local frame (MAV_FRAME_LOCAL_NED).
    '''
    time_usec : int
    pos_x : Tuple[float,float,float,float,float]
    pos_y : Tuple[float,float,float,float,float]
    pos_z : Tuple[float,float,float,float,float]
    delta : Tuple[float,float,float,float,float]
    pos_yaw : Tuple[float,float,float,float,float]
    valid_points : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QB20s20s20s20s20s', data, offset)
        args[2] = tuple(*struct.unpack('<5f', args[2]))
        args[3] = tuple(*struct.unpack('<5f', args[3]))
        args[4] = tuple(*struct.unpack('<5f', args[4]))
        args[5] = tuple(*struct.unpack('<5f', args[5]))
        args[6] = tuple(*struct.unpack('<5f', args[6]))
        return cls(*args)


@register('CELLULAR_STATUS', 334)
@dataclass
class CellularStatus(Unpackable):
    '''
    Report current used cellular network status
    '''
    mcc : int
    mnc : int
    lac : int
    status : CELLULAR_STATUS_FLAG
    failure_reason : CELLULAR_NETWORK_FAILED_REASON
    type : CELLULAR_NETWORK_RADIO_TYPE
    quality : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBBHHH', data, offset)
        return cls(*args)


@register('ISBD_LINK_STATUS', 335)
@dataclass
class IsbdLinkStatus(Unpackable):
    '''
    Status of the Iridium SBD link.
    '''
    timestamp : int
    last_heartbeat : int
    failed_sessions : int
    successful_sessions : int
    signal_quality : int
    ring_pending : int
    tx_session_pending : int
    rx_session_pending : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QQHHBBBB', data, offset)
        return cls(*args)


@register('CELLULAR_CONFIG', 336)
@dataclass
class CellularConfig(Unpackable):
    '''
    Configure cellular modems.
        This message is re-emitted as an acknowledgement by the modem.
        The message may also be explicitly requested using MAV_CMD_REQUEST_MESSAGE.
    '''
    enable_lte : int
    enable_pin : int
    pin : bytes
    new_pin : bytes
    apn : bytes
    puk : bytes
    roaming : int
    response : CELLULAR_CONFIG_RESPONSE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB16s16s32s16sBB', data, offset)
        return cls(*args)


@register('RAW_RPM', 339)
@dataclass
class RawRpm(Unpackable):
    '''
    RPM sensor data message.
    '''
    frequency : float
    index : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Bf', data, offset)
        return cls(*args)


@register('UTM_GLOBAL_POSITION', 340)
@dataclass
class UtmGlobalPosition(Unpackable):
    '''
    The global position resulting from GPS and sensor fusion.
    '''
    time : int
    lat : int
    lon : int
    alt : int
    relative_alt : int
    next_lat : int
    next_lon : int
    next_alt : int
    vx : int
    vy : int
    vz : int
    h_acc : int
    v_acc : int
    vel_acc : int
    update_rate : int
    uas_id : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    flight_state : UTM_FLIGHT_STATE
    flags : UTM_DATA_AVAIL_FLAGS

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Q18siiiihhhHHHiiiHBB', data, offset)
        args[1] = tuple(*struct.unpack('<18B', args[1]))
        return cls(*args)


@register('DEBUG_FLOAT_ARRAY', 350)
@dataclass
class DebugFloatArray(Unpackable):
    '''
    Large debug/prototyping array. The message uses the maximum available payload for data. The array_id and name fields are used to discriminate between messages in code and in user interfaces (respectively). Do not use in production code.
    '''
    time_usec : int
    array_id : int
    name : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<Q10sH', data, offset)
        return cls(*args)


@register('ORBIT_EXECUTION_STATUS', 360)
@dataclass
class OrbitExecutionStatus(Unpackable):
    '''
    Vehicle status report that is sent out while orbit execution is in progress (see MAV_CMD_DO_ORBIT).
    '''
    time_usec : int
    radius : float
    x : int
    y : int
    z : float
    frame : MAV_FRAME

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QfBiif', data, offset)
        return cls(*args)


@register('SMART_BATTERY_INFO', 370)
@dataclass
class SmartBatteryInfo(Unpackable):
    '''
    Smart Battery information (static/infrequent update). Use for updates from: smart battery to flight stack, flight stack to GCS. Use BATTERY_STATUS for the frequent battery updates.
    '''
    capacity_full_specification : int
    capacity_full : int
    cycle_count : int
    weight : int
    discharge_minimum_voltage : int
    charging_minimum_voltage : int
    resting_minimum_voltage : int
    id : int
    battery_function : MAV_BATTERY_FUNCTION
    type : MAV_BATTERY_TYPE
    serial_number : bytes
    device_name : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBiiH16s50sHHHH', data, offset)
        return cls(*args)


@register('FUEL_STATUS', 371)
@dataclass
class FuelStatus(Unpackable):
    '''
    Fuel status.
        This message provides "generic" fuel level information for display in a GCS and for triggering failsafes in an autopilot.
        The fuel type and associated units for fields in this message are defined in the enum MAV_FUEL_TYPE.

        The reported `consumed_fuel` and `remaining_fuel` must only be supplied if measured: they must not be inferred from the `maximum_fuel` and the other value.
        A recipient can assume that if these fields are supplied they are accurate.
        If not provided, the recipient can infer `remaining_fuel` from `maximum_fuel` and `consumed_fuel` on the assumption that the fuel was initially at its maximum (this is what battery monitors assume).
        Note however that this is an assumption, and the UI should prompt the user appropriately (i.e. notify user that they should fill the tank before boot).

        This kind of information may also be sent in fuel-specific messages such as BATTERY_STATUS_V2.
        If both messages are sent for the same fuel system, the ids and corresponding information must match.

        This should be streamed (nominally at 0.1 Hz).
    '''
    maximum_fuel : float
    consumed_fuel : float
    remaining_fuel : float
    flow_rate : float
    temperature : float
    fuel_type : MAV_FUEL_TYPE
    id : int
    percent_remaining : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BfffBffI', data, offset)
        return cls(*args)


@register('BATTERY_INFO', 372)
@dataclass
class BatteryInfo(Unpackable):
    '''
    Battery information that is static, or requires infrequent update.
        This message should requested using MAV_CMD_REQUEST_MESSAGE and/or streamed at very low rate.
        BATTERY_STATUS_V2 is used for higher-rate battery status information.
    '''
    discharge_minimum_voltage : float
    charging_minimum_voltage : float
    resting_minimum_voltage : float
    charging_maximum_voltage : float
    charging_maximum_current : float
    nominal_voltage : float
    discharge_maximum_current : float
    discharge_maximum_burst_current : float
    design_capacity : float
    full_charge_capacity : float
    cycle_count : int
    weight : int
    id : int
    battery_function : MAV_BATTERY_FUNCTION
    type : MAV_BATTERY_TYPE
    state_of_health : int
    cells_in_series : int
    manufacture_date : bytes
    serial_number : bytes
    name : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBBBHHffffffffff9s32s50s', data, offset)
        return cls(*args)


@register('GENERATOR_STATUS', 373)
@dataclass
class GeneratorStatus(Unpackable):
    '''
    Telemetry of power generation system. Alternator or mechanical generator.
    '''
    status : MAV_GENERATOR_STATUS_FLAG
    battery_current : float
    load_current : float
    power_generated : float
    bus_voltage : float
    bat_current_setpoint : float
    runtime : int
    time_until_maintenance : int
    generator_speed : int
    rectifier_temperature : int
    generator_temperature : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QHffffhfhIi', data, offset)
        return cls(*args)


@register('ACTUATOR_OUTPUT_STATUS', 375)
@dataclass
class ActuatorOutputStatus(Unpackable):
    '''
    The raw values of the actuator outputs (e.g. on Pixhawk, from MAIN, AUX ports). This message supersedes SERVO_OUTPUT_RAW.
    '''
    time_usec : int
    active : int
    actuator : Tuple[float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QI128s', data, offset)
        args[2] = tuple(*struct.unpack('<32f', args[2]))
        return cls(*args)


@register('TIME_ESTIMATE_TO_TARGET', 380)
@dataclass
class TimeEstimateToTarget(Unpackable):
    '''
    Time/duration estimates for various events and actions given the current vehicle state and position.
    '''
    safe_return : int
    land : int
    mission_next_item : int
    mission_end : int
    commanded_action : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<iiiii', data, offset)
        return cls(*args)


@register('TUNNEL', 385)
@dataclass
class Tunnel(Unpackable):
    '''
    Message for transporting "arbitrary" variable-length data from one component to another (broadcast is not forbidden, but discouraged). The encoding of the data is usually extension specific, i.e. determined by the source, and is usually not documented as part of the MAVLink specification.
    '''
    payload_type : MAV_TUNNEL_PAYLOAD_TYPE
    target_system : int
    target_component : int
    payload_length : int
    payload : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHB128s', data, offset)
        args[4] = tuple(*struct.unpack('<128B', args[4]))
        return cls(*args)


@register('CAN_FRAME', 386)
@dataclass
class CanFrame(Unpackable):
    '''
    A forwarded CAN frame as requested by MAV_CMD_CAN_FORWARD.
    '''
    id : int
    target_system : int
    target_component : int
    bus : int
    len : int
    data : Tuple[int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBBI8s', data, offset)
        args[5] = tuple(*struct.unpack('<8B', args[5]))
        return cls(*args)


@register('ONBOARD_COMPUTER_STATUS', 390)
@dataclass
class OnboardComputerStatus(Unpackable):
    '''
    Hardware status sent by an onboard computer.
    '''
    time_usec : int
    uptime : int
    ram_usage : int
    ram_total : int
    storage_type : Tuple[int,int,int,int]
    storage_usage : Tuple[int,int,int,int]
    storage_total : Tuple[int,int,int,int]
    link_type : Tuple[int,int,int,int,int,int]
    link_tx_rate : Tuple[int,int,int,int,int,int]
    link_rx_rate : Tuple[int,int,int,int,int,int]
    link_tx_max : Tuple[int,int,int,int,int,int]
    link_rx_max : Tuple[int,int,int,int,int,int]
    fan_speed : Tuple[int,int,int,int]
    type : int
    cpu_cores : Tuple[int,int,int,int,int,int,int,int]
    cpu_combined : Tuple[int,int,int,int,int,int,int,int,int,int]
    gpu_cores : Tuple[int,int,int,int]
    gpu_combined : Tuple[int,int,int,int,int,int,int,int,int,int]
    temperature_board : int
    temperature_core : Tuple[int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QIB8s10s4s10sb8s8sII16s16s16s24s24s24s24s24s', data, offset)
        args[3] = tuple(*struct.unpack('<8B', args[3]))
        args[4] = tuple(*struct.unpack('<10B', args[4]))
        args[5] = tuple(*struct.unpack('<4B', args[5]))
        args[6] = tuple(*struct.unpack('<10B', args[6]))
        args[8] = tuple(*struct.unpack('<8b', args[8]))
        args[9] = tuple(*struct.unpack('<4h', args[9]))
        args[12] = tuple(*struct.unpack('<4I', args[12]))
        args[13] = tuple(*struct.unpack('<4I', args[13]))
        args[14] = tuple(*struct.unpack('<4I', args[14]))
        args[15] = tuple(*struct.unpack('<6I', args[15]))
        args[16] = tuple(*struct.unpack('<6I', args[16]))
        args[17] = tuple(*struct.unpack('<6I', args[17]))
        args[18] = tuple(*struct.unpack('<6I', args[18]))
        args[19] = tuple(*struct.unpack('<6I', args[19]))
        return cls(*args)


@register('COMPONENT_INFORMATION', 395)
@dataclass
class ComponentInformation(Unpackable):
    '''
    Component information message, which may be requested using MAV_CMD_REQUEST_MESSAGE.
    '''
    time_boot_ms : int
    general_metadata_file_crc : int
    peripherals_metadata_file_crc : int
    general_metadata_uri : bytes
    peripherals_metadata_uri : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<II100sI100s', data, offset)
        return cls(*args)


@register('COMPONENT_INFORMATION_BASIC', 396)
@dataclass
class ComponentInformationBasic(Unpackable):
    '''
    Basic component information data. Should be requested using MAV_CMD_REQUEST_MESSAGE on startup, or when required.
    '''
    capabilities : MAV_PROTOCOL_CAPABILITY
    time_boot_ms : int
    time_manufacture_s : int
    vendor_name : bytes
    model_name : bytes
    software_version : bytes
    hardware_version : bytes
    serial_number : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IQI32s32s24s24s32s', data, offset)
        return cls(*args)


@register('COMPONENT_METADATA', 397)
@dataclass
class ComponentMetadata(Unpackable):
    '''
    Component metadata message, which may be requested using MAV_CMD_REQUEST_MESSAGE.

        This contains the MAVLink FTP URI and CRC for the component's general metadata file.
        The file must be hosted on the component, and may be xz compressed.
        The file CRC can be used for file caching.

        The general metadata file can be read to get the locations of other metadata files (COMP_METADATA_TYPE) and translations, which may be hosted either on the vehicle or the internet.
        For more information see: https://mavlink.io/en/services/component_information.html.

        Note: Camera components should use CAMERA_INFORMATION instead, and autopilots may use both this message and AUTOPILOT_VERSION.
    '''
    time_boot_ms : int
    file_crc : int
    uri : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<II100s', data, offset)
        return cls(*args)


@register('PLAY_TUNE_V2', 400)
@dataclass
class PlayTuneV2(Unpackable):
    '''
    Play vehicle tone/tune (buzzer). Supersedes message PLAY_TUNE.
    '''
    format : TUNE_FORMAT
    target_system : int
    target_component : int
    tune : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBI248s', data, offset)
        return cls(*args)


@register('SUPPORTED_TUNES', 401)
@dataclass
class SupportedTunes(Unpackable):
    '''
    Tune formats supported by vehicle. This should be emitted as response to MAV_CMD_REQUEST_MESSAGE.
    '''
    format : TUNE_FORMAT
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBI', data, offset)
        return cls(*args)


@register('EVENT', 410)
@dataclass
class Event(Unpackable):
    '''
    Event message. Each new event from a particular component gets a new sequence number. The same message might be sent multiple times if (re-)requested. Most events are broadcast, some can be specific to a target component (as receivers keep track of the sequence for missed events, all events need to be broadcast. Thus we use destination_component instead of target_component).
    '''
    id : int
    event_time_boot_ms : int
    sequence : int
    destination_component : int
    destination_system : int
    log_levels : int
    arguments : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBIIHB40s', data, offset)
        args[6] = tuple(*struct.unpack('<40B', args[6]))
        return cls(*args)


@register('CURRENT_EVENT_SEQUENCE', 411)
@dataclass
class CurrentEventSequence(Unpackable):
    '''
    Regular broadcast for the current latest event sequence number for a component. This is used to check for dropped events.
    '''
    sequence : int
    flags : MAV_EVENT_CURRENT_SEQUENCE_FLAGS

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<HB', data, offset)
        return cls(*args)


@register('REQUEST_EVENT', 412)
@dataclass
class RequestEvent(Unpackable):
    '''
    Request one or more events to be (re-)sent. If first_sequence==last_sequence, only a single event is requested. Note that first_sequence can be larger than last_sequence (because the sequence number can wrap). Each sequence will trigger an EVENT or EVENT_ERROR response.
    '''
    first_sequence : int
    last_sequence : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHH', data, offset)
        return cls(*args)


@register('RESPONSE_EVENT_ERROR', 413)
@dataclass
class ResponseEventError(Unpackable):
    '''
    Response to a REQUEST_EVENT in case of an error (e.g. the event is not available anymore).
    '''
    sequence : int
    sequence_oldest_available : int
    target_system : int
    target_component : int
    reason : MAV_EVENT_ERROR_REASON

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBHHB', data, offset)
        return cls(*args)


@register('ILLUMINATOR_STATUS', 440)
@dataclass
class IlluminatorStatus(Unpackable):
    '''
    Illuminator status
    '''
    uptime_ms : int
    error_status : ILLUMINATOR_ERROR_FLAGS
    brightness : float
    strobe_period : float
    strobe_duty_cycle : float
    temp_c : float
    min_strobe_period : float
    max_strobe_period : float
    enable : int
    mode_bitmask : ILLUMINATOR_MODE
    mode : ILLUMINATOR_MODE

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<IBBIBffffff', data, offset)
        return cls(*args)


@register('CANFD_FRAME', 387)
@dataclass
class CanfdFrame(Unpackable):
    '''
    A forwarded CANFD frame as requested by MAV_CMD_CAN_FORWARD. These are separated from CAN_FRAME as they need different handling (eg. TAO handling)
    '''
    id : int
    target_system : int
    target_component : int
    bus : int
    len : int
    data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBBI64s', data, offset)
        args[5] = tuple(*struct.unpack('<64B', args[5]))
        return cls(*args)


@register('CAN_FILTER_MODIFY', 388)
@dataclass
class CanFilterModify(Unpackable):
    '''
    Modify the filter of what CAN messages to forward over the mavlink. This can be used to make CAN forwarding work well on low bandwidth links. The filtering is applied on bits 8 to 24 of the CAN id (2nd and 3rd bytes) which corresponds to the DroneCAN message ID for DroneCAN. Filters with more than 16 IDs can be constructed by sending multiple CAN_FILTER_MODIFY messages.
    '''
    ids : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    target_system : int
    target_component : int
    bus : int
    operation : CAN_FILTER_OP
    num_ids : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBBB32s', data, offset)
        args[5] = tuple(*struct.unpack('<16H', args[5]))
        return cls(*args)


@register('WHEEL_DISTANCE', 9000)
@dataclass
class WheelDistance(Unpackable):
    '''
    Cumulative distance traveled for each reported wheel.
    '''
    time_usec : int
    distance : Tuple[float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float]
    count : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QB128s', data, offset)
        args[2] = tuple(*struct.unpack('<16d', args[2]))
        return cls(*args)


@register('WINCH_STATUS', 9005)
@dataclass
class WinchStatus(Unpackable):
    '''
    Winch status.
    '''
    time_usec : int
    line_length : float
    speed : float
    tension : float
    voltage : float
    current : float
    status : MAV_WINCH_STATUS_FLAG
    temperature : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<QfffffhI', data, offset)
        return cls(*args)


@register('OPEN_DRONE_ID_BASIC_ID', 12900)
@dataclass
class OpenDroneIdBasicId(Unpackable):
    '''
    Data for filling the OpenDroneID Basic ID message. This and the below messages are primarily meant for feeding data to/from an OpenDroneID implementation. E.g. https://github.com/opendroneid/opendroneid-core-c. These messages are compatible with the ASTM F3411 Remote ID standard and the ASD-STAN prEN 4709-002 Direct Remote ID standard. Additional information and usage of these messages is documented at https://mavlink.io/en/services/opendroneid.html.
    '''
    target_system : int
    target_component : int
    id_or_mac : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    id_type : MAV_ODID_ID_TYPE
    ua_type : MAV_ODID_UA_TYPE
    uas_id : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB20sBB20s', data, offset)
        args[2] = tuple(*struct.unpack('<20B', args[2]))
        args[5] = tuple(*struct.unpack('<20B', args[5]))
        return cls(*args)


@register('OPEN_DRONE_ID_LOCATION', 12901)
@dataclass
class OpenDroneIdLocation(Unpackable):
    '''
    Data for filling the OpenDroneID Location message. The float data types are 32-bit IEEE 754. The Location message provides the location, altitude, direction and speed of the aircraft.
    '''
    latitude : int
    longitude : int
    altitude_barometric : float
    altitude_geodetic : float
    height : float
    timestamp : float
    direction : int
    speed_horizontal : int
    speed_vertical : int
    target_system : int
    target_component : int
    id_or_mac : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    status : MAV_ODID_STATUS
    height_reference : MAV_ODID_HEIGHT_REF
    horizontal_accuracy : MAV_ODID_HOR_ACC
    vertical_accuracy : MAV_ODID_VER_ACC
    barometer_accuracy : MAV_ODID_VER_ACC
    speed_accuracy : MAV_ODID_SPEED_ACC
    timestamp_accuracy : MAV_ODID_TIME_ACC

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB20sBHHhiiffBfBBBBfB', data, offset)
        args[2] = tuple(*struct.unpack('<20B', args[2]))
        return cls(*args)


@register('OPEN_DRONE_ID_AUTHENTICATION', 12902)
@dataclass
class OpenDroneIdAuthentication(Unpackable):
    '''
    Data for filling the OpenDroneID Authentication message. The Authentication Message defines a field that can provide a means of authenticity for the identity of the UAS (Unmanned Aircraft System). The Authentication message can have two different formats. For data page 0, the fields PageCount, Length and TimeStamp are present and AuthData is only 17 bytes. For data page 1 through 15, PageCount, Length and TimeStamp are not present and the size of AuthData is 23 bytes.
    '''
    timestamp : int
    target_system : int
    target_component : int
    id_or_mac : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    authentication_type : MAV_ODID_AUTH_TYPE
    data_page : int
    last_page_index : int
    length : int
    authentication_data : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB20sBBBBI23s', data, offset)
        args[2] = tuple(*struct.unpack('<20B', args[2]))
        args[8] = tuple(*struct.unpack('<23B', args[8]))
        return cls(*args)


@register('OPEN_DRONE_ID_SELF_ID', 12903)
@dataclass
class OpenDroneIdSelfId(Unpackable):
    '''
    Data for filling the OpenDroneID Self ID message. The Self ID Message is an opportunity for the operator to (optionally) declare their identity and purpose of the flight. This message can provide additional information that could reduce the threat profile of a UA (Unmanned Aircraft) flying in a particular area or manner. This message can also be used to provide optional additional clarification in an emergency/remote ID system failure situation.
    '''
    target_system : int
    target_component : int
    id_or_mac : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    description_type : MAV_ODID_DESC_TYPE
    description : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB20sB23s', data, offset)
        args[2] = tuple(*struct.unpack('<20B', args[2]))
        return cls(*args)


@register('OPEN_DRONE_ID_SYSTEM', 12904)
@dataclass
class OpenDroneIdSystem(Unpackable):
    '''
    Data for filling the OpenDroneID System message. The System Message contains general system information including the operator location/altitude and possible aircraft group and/or category/class information.
    '''
    operator_latitude : int
    operator_longitude : int
    area_ceiling : float
    area_floor : float
    operator_altitude_geo : float
    timestamp : int
    area_count : int
    area_radius : int
    target_system : int
    target_component : int
    id_or_mac : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    operator_location_type : MAV_ODID_OPERATOR_LOCATION_TYPE
    classification_type : MAV_ODID_CLASSIFICATION_TYPE
    category_eu : MAV_ODID_CATEGORY_EU
    class_eu : MAV_ODID_CLASS_EU

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB20sBBiiHHffBBfI', data, offset)
        args[2] = tuple(*struct.unpack('<20B', args[2]))
        return cls(*args)


@register('OPEN_DRONE_ID_OPERATOR_ID', 12905)
@dataclass
class OpenDroneIdOperatorId(Unpackable):
    '''
    Data for filling the OpenDroneID Operator ID message, which contains the CAA (Civil Aviation Authority) issued operator ID.
    '''
    target_system : int
    target_component : int
    id_or_mac : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    operator_id_type : MAV_ODID_OPERATOR_ID_TYPE
    operator_id : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB20sB20s', data, offset)
        args[2] = tuple(*struct.unpack('<20B', args[2]))
        return cls(*args)


@register('OPEN_DRONE_ID_MESSAGE_PACK', 12915)
@dataclass
class OpenDroneIdMessagePack(Unpackable):
    '''
    An OpenDroneID message pack is a container for multiple encoded OpenDroneID messages (i.e. not in the format given for the above message descriptions but after encoding into the compressed OpenDroneID byte format). Used e.g. when transmitting on Bluetooth 5.0 Long Range/Extended Advertising or on WiFi Neighbor Aware Networking or on WiFi Beacon.
    '''
    target_system : int
    target_component : int
    id_or_mac : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]
    single_message_size : int
    msg_pack_size : int
    messages : Tuple[int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BB20sBB225s', data, offset)
        args[2] = tuple(*struct.unpack('<20B', args[2]))
        args[5] = tuple(*struct.unpack('<225B', args[5]))
        return cls(*args)


@register('OPEN_DRONE_ID_ARM_STATUS', 12918)
@dataclass
class OpenDroneIdArmStatus(Unpackable):
    '''
    Transmitter (remote ID system) is enabled and ready to start sending location and other required information. This is streamed by transmitter. A flight controller uses it as a condition to arm.
    '''
    status : MAV_ODID_ARM_STATUS
    error : bytes

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<B50s', data, offset)
        return cls(*args)


@register('OPEN_DRONE_ID_SYSTEM_UPDATE', 12919)
@dataclass
class OpenDroneIdSystemUpdate(Unpackable):
    '''
    Update the data in the OPEN_DRONE_ID_SYSTEM message with new location information. This can be sent to update the location information for the operator when no other information in the SYSTEM message has changed. This message allows for efficient operation on radio links which have limited uplink bandwidth while meeting requirements for update frequency of the operator location.
    '''
    operator_latitude : int
    operator_longitude : int
    operator_altitude_geo : float
    timestamp : int
    target_system : int
    target_component : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBiifI', data, offset)
        return cls(*args)


@register('HYGROMETER_SENSOR', 12920)
@dataclass
class HygrometerSensor(Unpackable):
    '''
    Temperature and humidity from hygrometer.
    '''
    temperature : int
    humidity : int
    id : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BhH', data, offset)
        return cls(*args)


@register('HEARTBEAT', 0)
@dataclass
class Heartbeat(Unpackable):
    '''
    The heartbeat message shows that a system or component is present and responding. The type and autopilot fields (along with the message component id), allow the receiving system to treat further messages from this system appropriately (e.g. by laying out the user interface based on the autopilot). This microservice is documented at https://mavlink.io/en/services/heartbeat.html
    '''
    custom_mode : int
    type : MAV_TYPE
    autopilot : MAV_AUTOPILOT
    base_mode : MAV_MODE_FLAG
    system_status : MAV_STATE
    mavlink_version : int

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<BBBIBB', data, offset)
        return cls(*args)


@register('PROTOCOL_VERSION', 300)
@dataclass
class ProtocolVersion(Unpackable):
    '''
    Version and capability of protocol version. This message can be requested with MAV_CMD_REQUEST_MESSAGE and is used as part of the handshaking to establish which MAVLink version should be used on the network. Every node should respond to a request for PROTOCOL_VERSION to enable the handshaking. Library implementers should consider adding this into the default decoding state machine to allow the protocol core to respond directly.
    '''
    version : int
    min_version : int
    max_version : int
    spec_version_hash : Tuple[int,int,int,int,int,int,int,int]
    library_version_hash : Tuple[int,int,int,int,int,int,int,int]

    @classmethod
    def unpack(cls, data, offset = 0):
        args = struct.unpack_from('<HHH8s8s', data, offset)
        args[3] = tuple(*struct.unpack('<8B', args[3]))
        args[4] = tuple(*struct.unpack('<8B', args[4]))
        return cls(*args)

